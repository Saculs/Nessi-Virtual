<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Nessi Nezzila</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="examples/main.css">

		<link rel='shortcut icon' href='favicon.ico' type='image/png' />
  		<link rel="icon" sizes="192x192" href="favicon.ico">
		<link rel="manifest" href="mani.webmanifest"/>

		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
		<style>
			
		</style>
	</head>
	<body>

		<div id="blocker">

			<div id="instructions">
				<span id='loadText' style="font-size:36px">Loading...</br> </br>Click to enter</span>
				<br /><br />
				Move: ARROWS / WASD<br/>
				Jump: SPACE<br/>
				Look: MOUSE
			</div>

		</div>

		

		<script type="module">

			import * as THREE from './build/three.module.js';

			import { PointerLockControls } from './examples/jsm/controls/PointerLockControls.js';
			import { GLTFLoader } from './examples/jsm/loaders/GLTFLoader.js';


			var loader = new GLTFLoader();

			var camera, scene, scene1, scene2, scene3,renderer, controls;

			var currentScene;

			var ufo;

			var scene1loaded = false;

			var scene2loaded = false;

			var scene3loaded = false;

			var objects = [];

			var raycaster;

			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();
			var direction = new THREE.Vector3();
			var vertex = new THREE.Vector3();
			var color = new THREE.Color();

			var manager = new THREE.LoadingManager();

manager.onProgress = function (item, loaded, total) {
    console.log(item, loaded, total);
};
manager.onLoad = function () {
    console.log('all items loaded');
};
manager.onError = function () {
    console.log('there has been an error');
};

			init();
			animate();

			function getRadian(x) {
				return (Math.PI*x)/180;
			}



			function initEnv(){

			


				var geometry = new THREE.BoxGeometry( 1400, 200, 2 );
var material = new THREE.MeshLambertMaterial( {color: 0x111111} );
var cube = new THREE.Mesh( geometry, material );
cube.position.set(100, 20, -103);
scene.add(cube);

var light = new THREE.PointLight( 0xFFFFFF, 1, 200 );
light.position.set(- 0, 35, 80);
scene.add( light );
			}

			function initUfo(){
			
				 var intloader = new GLTFLoader(manager);
				 intloader.load( "models/interior7.glb", function(gltf){
	var int = gltf.scene;

	int.scale.set(15,15,15);

    int.position.set(- 0, 0.50, 60);
	int.rotation.y = getRadian(-90);

    int.visible = true;



    int.traverse(function (o) {
      if (o.isMesh) {
	  console.log("interrior");
      }
    });
    scene.add(int);
	$("#loadText").html(  'loaded<br><br> click to ENTER');
  },
	// called while loading is progressing
	function ( xhr ) {
		console.log( 'interior ' + Math.floor( xhr.loaded / 25107276 * 100 ) +'% loaded' );
		$("#loadText").html( Math.floor( xhr.loaded / 25107276 * 100 ) + '% loaded<br><br> click to ENTER');
	}
	);

			}

			 

function goToScene(txt){
	console.log("go To Scene" + txt);
	camera.position.y = 10;
	camera.position.z = 30;
	var index = 0;
	switch(txt) {
  case "Space":
  index = 0;
  if(scene2loaded == false) initScene2();
	currentScene = scene2;
    break;
  case "Fire":
  index = 1;
  if(scene1loaded == false) initScene1();
	currentScene = scene1;
    break;
  case "UFO":
  index = 2;
  currentScene = scene;
  break;
case "AtomGas":
  index = 3;
  if(scene3loaded == false) initScene3();
	currentScene = scene3;
    break;
  default:
    switchScenes();
}

}

			function switchScenes(){
				camera.position.y = 10;
				camera.position.z = 30;
console.log("switch scenes");
if(currentScene == scene) {
	if(scene1loaded == false) initScene1();
	currentScene = scene1;
} else if(currentScene == scene1){
	if(scene2loaded == false) initScene2();
	currentScene = scene2;
}
else if(currentScene == scene2){
	if(scene3loaded == false) initScene3();
	currentScene = scene3;
}
else{currentScene = scene;}
currentScene.add(controls.getObject());
			}

			function initScene1(){
				scene1.add(controls.getObject());
				scene1loaded = true;

				var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
				light.position.set( 0.5, 1, 0.75 );
				scene1.add( light );

				var floorGeometry = new THREE.PlaneBufferGeometry( 2000, 2000, 100, 100 );
				floorGeometry.rotateX( - Math.PI / 2 );
				var floorMaterial = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide, color: 0x000000} );

				var floor = new THREE.Mesh( floorGeometry, floorMaterial );

				scene1.add(floor);

				var light = new THREE.PointLight( 0xFFFFFF, 2, 300 );
				light.position.set(- 0, 35, 80);
				scene1.add( light );
			


var somaloader = new GLTFLoader(manager);
somaloader.load( "models/somaTierenRetopo3.glb", function(gltf){
	var soma = gltf.scene;

	soma.scale.set(0.5,0.5,0.5);

    //soma.position.set(- 160, 6, 80);
	soma.rotation.y = getRadian(-90);

    soma.visible = true;



    soma.traverse(function (o) {
      if (o.isMesh) {
	  console.log("soma");
      }
    });
    scene1.add(soma);

  },
	// called while loading is progressing
	function ( xhr ) {
		console.log( 'soma ' + ( xhr.loaded) + '% loaded' );
		$("#loadText").html( Math.floor( xhr.loaded / 18102840 * 100 ) + '% loaded<br><br> click to ENTER');
	}
	);


				var ufoloader = new GLTFLoader(manager);
     ufoloader.load( "models/Spaceship.glb", function(gltf){
	var ufo = gltf.scene;

	  ufo.scale.set(45,45,45);

    ufo.position.set(- 260, 40, 100);
	ufo.rotation.y = getRadian(-80);
	ufo.rotation.x = getRadian(-10);

    ufo.visible = true;



    ufo.traverse(function (o) {
      if (o.isMesh) {
	  console.log("UFO");
      }
    });
    scene1.add(ufo);
  },
	// called while loading is progressing
	function ( xhr ) {

		//console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

	}
	);

			}

			function initScene2(){

scene2loaded = true;
scene2.add(controls.getObject());

var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
light.position.set( 0.5, 1, 0.75 );
scene2.add( light );

var light = new THREE.PointLight( 0xFFFFFF, 2, 300 );
light.position.set(- 0, 35, 80);
scene2.add( light );


scene2.add(ufo);

var ufoloader = new GLTFLoader(manager);
     ufoloader.load( "models/Spaceship.glb", function(gltf){
	var ufo = gltf.scene;

	  ufo.scale.set(45,45,45);

    ufo.position.set(- 260, 40, 100);
	ufo.rotation.y = getRadian(-80);
	ufo.rotation.x = getRadian(-10);

    ufo.visible = true;



    ufo.traverse(function (o) {
      if (o.isMesh) {
	  console.log("UFO");
      }
    });
	scene2.add(ufo);
	console.log( 'ufo added to scene' );
  },
	// called while loading is progressing
	function ( xhr ) {
		console.log( 'ufo ' + ( xhr.loaded ) + 'loaded' );
		$("#loadText").html( Math.floor( xhr.loaded / 13590768 * 100 ) + '% loaded<br><br> click to ENTER');
	}
	);

/*

var uniforms = {  
texture: { type: 't', value: THREE.ImageUtils.loadTexture('textures/Nebula.png') }
};

var material = new THREE.ShaderMaterial( {  
uniforms:       uniforms,
vertexShader:   document.getElementById('sky-vertex').textContent,
fragmentShader: document.getElementById('sky-fragment').textContent
});
*/
var material = new THREE.MeshBasicMaterial();
material.map = new THREE.TextureLoader().load("textures/Nebula.png");
material.color = new THREE.Color( 0xFFFFFF );
material.side = THREE.BackSide;

scene2.add(new THREE.Mesh(new THREE.SphereGeometry(700, 60, 40), material) ); 

}

function initScene3(){

scene3loaded = true;
scene3.add(controls.getObject());

var light = new THREE.HemisphereLight( 0xFFFFFF, 5,  300 );
light.position.set( 1, 10, 0.75 );
scene3.add( light );

var amblight = new THREE.AmbientLight( 0x02FD01,4 ); // soft white light
scene3.add( amblight );

var light2 = new THREE.PointLight( 0xFFFFFF, 1, 1600 );
light2.position.set(0.5, 10, 3);
scene3.add( light2 );

var moonloader = new GLTFLoader(manager);
moonloader.load( "models/moon4.glb", function(gltf){
	var moon = gltf.scene;

	moon.scale.set(0.5,0.5,0.5);

    //moon.position.set(- 160, 6, 80);
	moon.rotation.y = getRadian(-90);

    moon.visible = true;



    moon.traverse(function (o) {
      if (o.isMesh) {
	  console.log("moon");
      }
    });
    scene3.add(moon);

  },
	// called while loading is progressing
	function ( xhr ) {
		console.log( 'moon ' + ( xhr.loaded) + '% loaded' );
		$("#loadText").html( Math.floor( xhr.loaded / 45492188 * 100 ) + '% loaded<br><br> click to ENTER');
	}
	);



/*

var uniforms = {  
texture: { type: 't', value: THREE.ImageUtils.loadTexture('textures/Nebula.png') }
};

var material = new THREE.ShaderMaterial( {  
uniforms:       uniforms,
vertexShader:   document.getElementById('sky-vertex').textContent,
fragmentShader: document.getElementById('sky-fragment').textContent
});
*/
var material = new THREE.MeshBasicMaterial();
material.map = new THREE.TextureLoader().load("textures/Aurora3.png");
material.color = new THREE.Color( 0xFFFFFF );
material.side = THREE.BackSide;

scene3.add(new THREE.Mesh(new THREE.SphereGeometry(260, 60, 40), material) ); 

}




			function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1500 );
				camera.position.y = 10;
				camera.position.z = 30;
				scene = new THREE.Scene();
				currentScene = scene;
				scene1 = new THREE.Scene();
				scene2 = new THREE.Scene();
				scene3 = new THREE.Scene();
				ufo = new THREE.Object3D();
				scene.background = new THREE.Color( 0x000000 );
				//scene1.background = new THREE.Color( 0x000000 );
				scene.fog = new THREE.Fog( 0xffffff, 0, 750 );
				//scene1.fog = new THREE.Fog( 0xffffff, 0, 1100 );
				scene3.fog = new THREE.Fog( 0x02FD01, 0, 900 );

				var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 2 );
				light.position.set( 0.5, 3, 0.75 );
				scene.add( light );

				controls = new PointerLockControls( camera, document.body );

				var blocker = document.getElementById( 'blocker' );
				var instructions = document.getElementById( 'instructions' );
				/*
				var footer = document.getElementById( 'footer' );
				
				footer.addEventListener( 'click', switchScenes, false );
*/

				$('#footer a').click(function(e) {
  var txt = $(e.target).text();
  console.log(txt);
goToScene(txt);					
});


				instructions.addEventListener( 'click', function () {

					controls.lock();

				}, false );

				document.body.addEventListener( 'touchstart', function () {

					controls.lock();
					console.log("touchstart");
					instructions.style.display = 'none';
					blocker.style.display = 'none';
				}, false );


				controls.addEventListener( 'lock', function () {

					instructions.style.display = 'none';
					blocker.style.display = 'none';

				} );

				controls.addEventListener( 'unlock', function () {

					blocker.style.display = 'block';
					instructions.style.display = '';

				} );

				scene.add( controls.getObject() );

				var onKeyDown = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true;
							break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							break;

						case 32: // space
							if ( canJump === true ) velocity.y += 300;
							canJump = false;
							break;

					}

				};

				var onKeyUp = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;

					}

				};

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );

				raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3( 0, - 1, 0 ), 0, 10 );

				// floor

				var floorGeometry = new THREE.PlaneBufferGeometry( 2000, 2000, 100, 100 );
				floorGeometry.rotateX( - Math.PI / 2 );

				// vertex displacement
				/*

				var position = floorGeometry.attributes.position;

				for ( var i = 0, l = position.count; i < l; i ++ ) {

					vertex.fromBufferAttribute( position, i );

					vertex.x += Math.random() * 20 - 10;
					vertex.y += Math.random() * 2;
					vertex.z += Math.random() * 20 - 10;

					position.setXYZ( i, vertex.x, vertex.y, vertex.z );

				}

				floorGeometry = floorGeometry.toNonIndexed(); // ensure each face has unique vertices

				position = floorGeometry.attributes.position;
				var colors = [];

				for ( var i = 0, l = position.count; i < l; i ++ ) {

					color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
					colors.push( color.r, color.g, color.b );

				}

				floorGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 0 ) );
				*/

				var floorMaterial = new THREE.MeshLambertMaterial( { side: THREE.DoubleSide, color: 0x000000} );

				var floor = new THREE.Mesh( floorGeometry, floorMaterial );
				var ceiling = new THREE.Mesh( floorGeometry, floorMaterial );
				scene.add( floor );
				scene.add( ceiling);
				ceiling.position.set(0, 80, 0);

				 

				// objects
				/*
				var boxGeometry = new THREE.BoxBufferGeometry( 20, 20, 20 );
				boxGeometry = boxGeometry.toNonIndexed(); // ensure each face has unique vertices

				position = boxGeometry.attributes.position;
				colors = [];

				for ( var i = 0, l = position.count; i < l; i ++ ) {

					color.setHSL( Math.random() * 0.3 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );
					colors.push( color.r, color.g, color.b );

				}

				boxGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

				for ( var i = 0; i < 500; i ++ ) {

					var boxMaterial = new THREE.MeshPhongMaterial( { specular: 0xffffff, flatShading: true, vertexColors: true } );
					boxMaterial.color.setHSL( Math.random() * 0.2 + 0.5, 0.75, Math.random() * 0.25 + 0.75 );

					var box = new THREE.Mesh( boxGeometry, boxMaterial );
					box.position.x = Math.floor( Math.random() * 20 - 10 ) * 20;
					box.position.y = Math.floor( Math.random() * 20 ) * 20 + 10;
					box.position.z = Math.floor( Math.random() * 20 - 10 ) * 20;

					scene.add( box );
					objects.push( box );

				}
				*/
				//

				//initPaintings();
				initEnv();
				initUfo();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				if ( controls.isLocked === true ) {

					raycaster.ray.origin.copy( controls.getObject().position );
					raycaster.ray.origin.y -= 10;

					var intersections = raycaster.intersectObjects( objects );

					var onObject = intersections.length > 0;

					var time = performance.now();
					var delta = ( time - prevTime ) / 1000;

					velocity.x -= velocity.x * 10.0 * delta;
					velocity.z -= velocity.z * 10.0 * delta;

					velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

					direction.z = Number( moveForward ) - Number( moveBackward );
					direction.x = Number( moveRight ) - Number( moveLeft );
					direction.normalize(); // this ensures consistent movements in all directions

					if ( moveForward || moveBackward ) velocity.z -= direction.z * 400.0 * delta;
					if ( moveLeft || moveRight ) velocity.x -= direction.x * 400.0 * delta;

					if ( onObject === true ) {

						velocity.y = Math.max( 0, velocity.y );
						canJump = true;

					}

					controls.moveRight( - velocity.x * delta );
					controls.moveForward( - velocity.z * delta );

					controls.getObject().position.y += ( velocity.y * delta ); // new behavior

					if ( controls.getObject().position.y < 10 ) {

						velocity.y = 0;
						controls.getObject().position.y = 10;

						canJump = true;

					}

					prevTime = time;

				}

				

				renderer.render( currentScene, camera );

			}

		</script>




<div id="footer">

	<a>Space</a> <a>Fire</a> <a>UFO</a> <a>AtomGas</a>
</div>

	</body>
</html>
