<!DOCTYPE html>
<html lang="en">

<head>
	<title>Nessi Nezzila</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="examples/main.css">

	<link rel='shortcut icon' href='favicon.ico' type='image/png' />
	<link rel="icon" sizes="192x192" href="favicon.ico">
	<link rel="manifest" href="mani.webmanifest" />

	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>

	<link rel="stylesheet" type="text/css" href="loading-bar.css" />
	<script type="text/javascript" src="loading-bar.js"></script>

	<style type="text/css">
		.ldBar path.mainline {
			stroke-width: 10;
			stroke: #f1f2f3;
		}

		.ldBar path.baseline {
			stroke-width: 18;
			stroke: #272727;
		}

		#myProgress {
			width: 100%;
			background-color: black;


			position: absolute;
			bottom: 30%;

		}

		#myBar {
			width: 1%;
			height: 0px;
			background-color: rgb(248, 47, 255);


		}

		#crossHair {
			width: 2%;
			top: 50%;
			left: 50%;
			position: absolute;
			margin-right: -50%;
			transform: translate(-50%, -50%);
			display: none;
		}

		#loadText {
			font-size: 45px;
			position: absolute;
			line-height: 1.5;
			top: 30%;
			left: 0;
			right: 0;

			/* Create the gradient. 
			background-color: #CA4246;
			background-image: linear-gradient(0deg,
					rgb(248, 47, 255) 90.666%,
					#ffffff 10.333%);


			/* Set the background size and repeat properties. 
			background-size: 100%;
			background-repeat: repeat;

			/* Use the text as a mask for the background. 
			/* This will show the gradient as a text color rather than element bg.
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;*/
		}

		#instructions {
			line-height: 2;
			opacity: 1;
			transition: opacity 1s;
		}

		#instructions.fade {
			opacity: 0;
		}

		#blocker {
			opacity: 1;
			transition: opacity 1s;
			z-index: 10;
		}

		#blocker.fade {
			opacity: 0;
			z-index: 0;
		}

		#clickToEnter {
			font-size: 45px;
			cursor: pointer;
			-webkit-animation: colorpulse 4s infinite alternate;
			animation: colorpulse 4s infinite alternate;
		}

		@-webkit-keyframes colorpulse {
			0% {
				color: #009e85;
			}

			25% {
				color: #ea309c;
			}

			50% {
				color: #f59c0d;
			}

			75% {
				color: #2482b9;
			}
		}

		@keyframes colorpulse {
			0% {
				color: #009e85;
			}

			25% {
				color: #ea309c;
			}

			50% {
				color: #f59c0d;
			}

			75% {
				color: #2482b9;
			}
		}

		@keyframes rotation {
			from {
				transform: rotate(0deg);
			}

			to {
				transform: rotate(359deg);
			}
		}

		#forward {
			position: fixed;
			z-index: 8;
			left: 47%;
			margin-bottom: 10px;
			cursor: pointer;
			bottom: 40px;
			width: 6%;
			height: 20px;
			background-image: url("textures/forward.png");
			background-size: 100% 100%;

			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-o-user-select: none;
			user-select: none;
			touch-action: none;


		}
	</style>

</head>

<body>
	<img src="mouse.png" id="crossHair">
	<div id="blocker">

		<div id="instructions">
			<div>

				<span id='loadText'>Loading...</span>


			</div>
			<div id="myProgress">
				<div id="myBar"></div>
			</div>

			<br /><br />
			Move: ARROWS / WASD<br />
			Look: MOUSE</br>
			Interact: CLICK

		</div>

	</div>


	<script type="module">

		//(function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = '//mrdoob.github.io/stats.js/build/stats.min.js'; document.head.appendChild(script); })()

		import * as THREE from './build/three.module.js';

		import { PointerLockControls } from './examples/jsm/controls/PointerLockControls.js';
		import { GLTFLoader } from './examples/jsm/loaders/GLTFLoader.js';

		import { DecalGeometry } from './examples/jsm/geometries/DecalGeometry.js';

		import { FireShader } from './FireShader.js';

		import {
			Euler,
			EventDispatcher,
			Vector3
		} from "./build/three.module.js";

		var isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
		var isAppleDevice = navigator.userAgent.includes('Macintosh');
		var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
		console.log("isAPPLE DEVICE = " + isAppleDevice, 'isChrome ' + isChrome, 'isMobile  ' + isMobile);

		var loader = new GLTFLoader();

		var camera, scene, scene1, scene2, scene3, renderer, controls;



		var mixer, mixer2, mixer3;



		var tutorial = true;
		var transition = true;
		var canClick = true;



		var rocks, door, gasSphere, tsph;


		var currentScene;
		var currentSceneLoaded = false;

		var index = 2;

		var scene0loaded = false;

		var scene1loaded = false;

		var scene2loaded = true;

		var scene3loaded = false;

		var fireAnim;


		var listener, sound;


		//Party

		var TO_RADIANS = Math.PI / 180;
		var particle;
		var particles = [];
		var particleS;
		var particlesS = [];
		var Particle3D = function (material) {
			THREE.Sprite.call(this, material);

			//this.material = material instanceof Array ? material : [ material ];
			// define properties
			this.velocity = new THREE.Vector3(0, -0.4, 0);
			this.velocity.rotateX(randomRange(-45, 45));
			this.velocity.rotateY(randomRange(0, 360));
			this.gravity = new THREE.Vector3(0, 0, 0);

			this.drag = 1;
			// methods...
		};

		Particle3D.prototype = new THREE.Sprite();
		Particle3D.prototype.constructor = Particle3D;

		Particle3D.prototype.updatePhysics = function () {
			this.velocity.multiplyScalar(this.drag);
			this.velocity.add(this.gravity);
			this.position.add(this.velocity);
		}

		THREE.Vector3.prototype.rotateY = function (angle) {
			var cosRY = Math.cos(angle * TO_RADIANS);
			var sinRY = Math.sin(angle * TO_RADIANS);

			var tempz = this.z;;
			var tempx = this.x;

			this.x = (tempx * cosRY) + (tempz * sinRY);
			this.z = (tempx * -sinRY) + (tempz * cosRY);
		}

		THREE.Vector3.prototype.rotateX = function (angle) {
			var cosRY = Math.cos(angle * TO_RADIANS);
			var sinRY = Math.sin(angle * TO_RADIANS);

			var tempz = this.z;;
			var tempy = this.y;

			this.y = (tempy * cosRY) + (tempz * sinRY);
			this.z = (tempy * -sinRY) + (tempz * cosRY);
		}

		THREE.Vector3.prototype.rotateZ = function (angle) {
			var cosRY = Math.cos(angle * TO_RADIANS);
			var sinRY = Math.sin(angle * TO_RADIANS);

			var tempx = this.x;;
			var tempy = this.y;

			this.y = (tempy * cosRY) + (tempx * sinRY);
			this.x = (tempy * -sinRY) + (tempx * cosRY);
		}

		// returns a random number between the two limits provided

		function randomRange(min, max) {
			return ((Math.random() * (max - min)) + min);
		}
		//Party End





		var crossHair;

		var objects = [];

		var rocksGeo = [];
		var rocksMats = [];

		var raycaster, raycaster2;
		var mouse;

		var clock;
		var fire, fire2, fire3, fire4, fire5;


		var moveForward = false;
		var moveBackward = false;
		var moveLeft = false;
		var moveRight = false;
		var canJump = false;

		var prevTime = performance.now();
		var velocity = new THREE.Vector3();
		var direction = new THREE.Vector3();
		var vertex = new THREE.Vector3();
		var color = new THREE.Color();

		var manager = new THREE.LoadingManager();

		manager.onProgress = function (item, loaded, total) {
			console.log( loaded, total);
		};
		manager.onLoad = function () {
			console.log('all items loaded');
		};
		manager.onError = function () {
			console.log('there has been an error');
		};

		var elem = document.getElementById("myBar");
		var loading = document.getElementById("myProgress");

		var Fire = function (fireTex, color) {

			var fireMaterial = new THREE.ShaderMaterial({
				defines: FireShader.defines,
				uniforms: THREE.UniformsUtils.clone(FireShader.uniforms),
				vertexShader: FireShader.vertexShader,
				fragmentShader: FireShader.fragmentShader,
				transparent: true,
				depthWrite: false,
				depthTest: true
			});

			// initialize uniforms 

			fireTex.magFilter = fireTex.minFilter = THREE.LinearFilter;
			fireTex.wrapS = fireTex.wrapT = THREE.ClampToEdgeWrapping;

			fireMaterial.uniforms.fireTex.value = fireTex;
			fireMaterial.uniforms.color.value = color || new THREE.Color(0xeeeeee);
			fireMaterial.uniforms.invModelMatrix.value = new THREE.Matrix4();
			fireMaterial.uniforms.scale.value = new THREE.Vector3(1, 1, 1);
			fireMaterial.uniforms.seed.value = Math.random() * 19.19;
			fireMaterial.uniforms.magnitude.value = 2.6;


			THREE.Mesh.call(this, new THREE.BoxGeometry(1.0, 1.0, 1.0), fireMaterial);
		};

		Fire.prototype = Object.create(THREE.Mesh.prototype);
		Fire.prototype.constructor = THREE.Fire;

		Fire.prototype.update = function (time) {

			var invModelMatrix = this.material.uniforms.invModelMatrix.value;

			this.updateMatrixWorld();
			invModelMatrix.getInverse(this.matrixWorld);

			if (time !== undefined) {
				this.material.uniforms.time.value = time;
			}

			this.material.uniforms.invModelMatrix.value = invModelMatrix;

			this.material.uniforms.scale.value = this.scale;
		};

		init();
		animate();



		function getRadian(x) {
			return (Math.PI * x) / 180;
		}
		function getEuler(x) {
			return x * (180 / Math.PI);
		}

		function initEnv() {
			var geometry = new THREE.BoxGeometry(1400, 200, 2);
			var material = new THREE.MeshLambertMaterial({ color: 0x111111 });
			var cube = new THREE.Mesh(geometry, material);
			cube.position.set(100, 20, -103);
			//scene.add(cube);

			var light = new THREE.PointLight(0xFFFFFF, 1, 200);
			light.position.set(- 0, 35, 80);
			scene.add(light);
		}

		function initUfo() {

			scene0loaded = true;
			initEnv();
			var intloader = new GLTFLoader(manager);
			intloader.load("models/interior8.glb", function (gltf) {
				var int = gltf.scene;

				int.scale.set(12, 12, 12);

				int.position.set(- 0, 0.50, 30);
				int.rotation.y = getRadian(-90);

				int.visible = true;
				var floorMaterial = new THREE.MeshStandardMaterial({ side: THREE.DoubleSide, color: 0x000000, roughness: 0, specular: 0 });
				int.traverse(function (o) {
					if (o.isMesh) {
						console.log("interrior");
						if (o.name == 'Walls') {
							o.material = floorMaterial;
						} else if (o.name == "PlaneTop") {
							var huTex = new THREE.TextureLoader().load("textures/UFO.png");
							var huMat = new THREE.MeshPhongMaterial({ map: huTex, transparent: true, opacity: 1, side: THREE.DoubleSide });
							o.material = huMat;
						}
					}
				});
				scene.add(int);
				loaded();
			},
				// called while loading is progressing
				function (xhr) {
					var prc = Math.floor(xhr.loaded / 6275116 * 100);
					console.log('interior ' + xhr.loaded + ' loaded');

					updateLoadBar(prc);
				}
			);

			var doorloader = new GLTFLoader(manager);
			doorloader.load("models/DoorRetopo4.glb", function (gltf) {
				var door = gltf.scene;

				door.scale.set(3, 3, 3);

				door.position.set(-55, 1, 5);
				door.rotation.y = getRadian(-30);

				door.visible = true;



				door.traverse(function (o) {
					if (o.isMesh) {
						console.log("door");
						if (o.name == "Invisible") {
							o.material = new THREE.MeshStandardMaterial({ color: 0x000000 });
						}

					}
				});
				scene.add(door);
				//loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('door ' + (xhr.loaded) + '% loaded');
					var prc = Math.floor(xhr.loaded / 3027156 * 100);

				}
			);

			var babyloader = new GLTFLoader(manager);
			babyloader.load("models/Puppe1R.glb", function (gltf) {
				var baby = gltf.scene;
				var z = 0;
				baby.scale.set(7, 7, 7);

				baby.position.set(- 0, 1, 30);
				baby.rotation.y = getRadian(-90);

				baby.visible = true;

				baby.traverse(function (o) {
					if (o.isMesh) {
						console.log("babyerrior");
						o.material.spaculer = 1;
					}
				});
				scene.add(baby);
				//loaded();
			},
				// called while loading is progressing
				function (xhr) {
					//var prc = Math.floor(xhr.loaded / 25107276 * 100);
					console.log('babyerior ' + xhr + ' loaded');

					//updateLoadBar(prc);
				}
			);

		}

		function updateLoadBar(prc) {
			elem.style.width = prc + "%";
			$("#loadText").html('loading<br>' + prc + '%');
			$('html,body').css('cursor', 'default');
			/*
			if (prc == 100) loading.style.display = 'none';
			else loading.style.display = 'block';
			*/
		}

		function loaded() {
			currentSceneLoaded = true;
			if (tutorial == true) {
				$("#loadText").html('<div id="clickToEnter" > </div>');
				$("#clickToEnter").html('click To Enter');
				//tutorial = false;
				$('html,body').css('cursor', 'pointer');

			} else {
				$("#loadText").html('loaded');
				$('html,body').css('cursor', 'pointer');
				controls.lock();
				fadeInstr();
				transition = false;
				//instructions.style.display = 'none';
				//blocker.style.display = 'none';
				//instructions.classList.toggle('fade');
				//blocker.classList.toggle('fade');
			}

		}


		function goToScene(txt) {
			currentSceneLoaded = false;
			console.log("go To Scene" + txt);
			camera.position.z = 30;
			var euler = new Euler(0, 0, 0, 'YXZ');
			camera.quaternion.setFromEuler(euler);
			playSound(txt);
			switch (txt) {
				case "Space":
					index = 2;
					if (scene2loaded == false) {
						updateLoadBar(0);
						initScene2();
					} else loaded();

					currentScene = scene2;
					break;
				case "Fire":
					index = 1;
					if (scene1loaded == false) {
						updateLoadBar(0);
						initScene1();
					} else loaded();
					currentScene = scene1;
					break;
				case "UFO":
					index = 0;
					if (scene0loaded == false) {
						initScene0();
						updateLoadBar(0);
					} else loaded();
					currentScene = scene;
					break;
				case "AtomGas":
					index = 3;
					if (scene3loaded == false) {
						initScene3();
						updateLoadBar(0);
					} else loaded();
					currentScene = scene3;
					break;
				default:
					switchScenes();
			}

			currentScene.add(controls.getObject());

		}

		function playSound(txt) {
			// load a sound and set it as the Audio object's buffer
			/*
			var audioLoader = new THREE.AudioLoader();
			audioLoader.load('Sound/' + txt + '.ogg', function (buffer) {
				sound.pause();
				// how to reset?
				sound.setBuffer(buffer);
				sound.setLoop(true);
				sound.setVolume(0.6);
				sound.play();
			});
			*/
			var audio = document.getElementById('audio');
			audio.play();

		}

		function switchScenes() {
			camera.position.y = 10;
			camera.position.z = 30;
			console.log("switch scenes");
			if (currentScene == scene) {
				if (scene1loaded == false) initScene1();
				currentScene = scene1;
			} else if (currentScene == scene1) {
				if (scene2loaded == false) initScene2();
				currentScene = scene2;
			}
			else if (currentScene == scene2) {
				if (scene3loaded == false) initScene3();
				currentScene = scene3;
			}
			else { currentScene = scene; }
		}

		function initScene0() {
			initUfo();
		}

		function initScene1() {
			//scene1.add(controls.getObject());
			scene1loaded = true;

			var amblight = new THREE.AmbientLight(0xFFFFFf, 0.1);
			scene1.add(amblight);

			var light = new THREE.HemisphereLight(0xeeeeff, 0.3, 0.75);
			light.position.set(0.5, 1, 0.75);
			//scene1.add(light);

			var ufolight = new THREE.PointLight(0xeeeeff, 40, 50);
			ufolight.position.set(-80, 55, -100);
			scene1.add(ufolight);
			var ufolight2 = new THREE.PointLight(0xeeeeff, 40, 50);
			ufolight2.position.set(30, 70, -120);
			scene1.add(ufolight2);

			var light2 = new THREE.PointLight(0xf9c59d, 2, 80);
			light2.position.set(10, 30, 30);
			scene1.add(light2);


			var light4 = new THREE.PointLight(0xd31313, 5, 26);
			light4.position.set(-50, 4, -8);
			scene1.add(light4);

			var light5 = new THREE.PointLight(0xd31313, 5, 26);
			light5.position.set(10, 4, 66);
			scene1.add(light5);

			var floorGeometry = new THREE.PlaneBufferGeometry(2000, 2000, 100, 100);
			floorGeometry.rotateX(- Math.PI / 2);
			var floorMaterial = new THREE.MeshLambertMaterial({ side: THREE.DoubleSide, color: 0x000000 });

			var floor = new THREE.Mesh(floorGeometry, floorMaterial);

			//scene1.add(floor);

			var light3 = new THREE.PointLight(0xd31313, 5, 26);
			light3.position.set(0, 15, -30);
			scene1.add(light3);



			var runnerTexture = new THREE.TextureLoader().load('textures/FireTest.jpg');
			fireAnim = new TextureAnimator(runnerTexture, 8, 5, 40, 75); // texture, #horiz, #vert, #total, duration.
			var runnerMaterial = new THREE.MeshBasicMaterial({ map: runnerTexture, side: THREE.DoubleSide });
			var runnerGeometry = new THREE.PlaneGeometry(20, 20, 1, 1);
			var runner = new THREE.Mesh(runnerGeometry, runnerMaterial);
			runner.position.set(-10, 16, -40);
			//scene1.add(runner);


			var somaloader = new GLTFLoader(manager);
			somaloader.load("models/somaTierenRetopoJPG.glb", function (gltf) {
				var soma = gltf.scene;

				soma.scale.set(0.3, 0.3, 0.3);

				//soma.position.set(- 160, 6, 80);
				soma.rotation.y = getRadian(-90);

				soma.visible = true;
				soma.position.set(0, 2, 20);



				soma.traverse(function (o) {
					if (o.isMesh) {
						console.log("soma");
					}
				});
				scene1.add(soma);
				//loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('soma ' + (xhr.loaded) + 'loaded');
					var prc = Math.floor(xhr.loaded / 4372972 * 100);

					updateLoadBar(prc);
				}
			);

			var bildloader = new GLTFLoader(manager);
			bildloader.load("models/All Bilds retopoGLTF.glb", function (gltf) {
				var bild = gltf.scene;

				bild.scale.set(0.17, 0.17, 0.17);
				bild.position.set(0, 5, 0);


				bild.rotation.y = getRadian(-90);

				bild.visible = true;

				bild.traverse(function (o) {
					if (o.isMesh) {
						//console.log(o.name);
						var map = o.material.map;
						var huMat = new THREE.MeshPhongMaterial({ map: map, transparent: true, opacity: 1, side: THREE.DoubleSide });
						o.material = huMat;
						o.rotation.z = getRadian(-90);
						switch (o.name) {
							case "Bild_5_Retopo":
								o.position.set(-80, 5, 250);
								o.rotation.x = getRadian(45);
								break;
							case "Bild_2_Retopo":
								o.position.set(-120, 5, -60);
								o.rotation.x = getRadian(90);
								o.rotation.z = getRadian(-30);
								break;
							case "Bild1_Retopo":
								o.position.set(380, 30, -30);
								o.rotation.z = getRadian(90);
								break;
							case "Bild_3_Retopo":
								o.position.set(110, 3, 200);
								o.rotation.x = getRadian(-20);
								o.rotation.z = getRadian(0);
								break;
							case "Bild_4_retopo_Back":
								o.position.set(110, 6.2, -200);
								o.rotation.z = getRadian(-10);
								o.rotation.x = getRadian(10);
								break;
						}
					}
				});
				scene1.add(bild);
				//loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('bild ' + (xhr.loaded) + '% loaded');
					var prc = Math.floor(xhr.loaded / 18102840 * 100);

				}
			);


			var Debrisloader = new GLTFLoader(manager);
			Debrisloader.load("models/DebrisSolo2.glb", function (gltf) {
				var Debris = gltf.scene;

				Debris.scale.set(20, 20, 20);

				Debris.position.set(-10, 0, 40);
				Debris.rotation.y = getRadian(-90);

				Debris.visible = true;

				var geometry;
				var material;

				Debris.traverse(function (o) {
					if (o.isMesh) {
						//console.log(o.name);
						geometry = o.geometry;
						material = o.material;
					}
				});




				makeInstanced(geometry, material);

				//scene1.add(Debris);
				loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('door ' + (xhr.loaded) + ' loaded');
					var prc = Math.floor(xhr.loaded / 32162816 * 100);

				}
			);
			//material that the geometry will use 

			var doorloader = new GLTFLoader(manager);
			doorloader.load("models/DoorRetopo4.glb", function (gltf) {
				var door = gltf.scene;

				door.scale.set(5, 5, 5);

				door.position.set(20, 0, -10);
				door.rotation.y = getRadian(45);

				door.visible = true;



				door.traverse(function (o) {
					if (o.isMesh) {
						console.log("door");
						o.castShadow = true;
						if (o.name == "Plane002") {
							//o.rotation.y = getRadian(90);
						} else if (o.name == "Invisible") {
							o.material = new THREE.MeshStandardMaterial({ color: 0x000000 });
						}

					}
				});
				scene1.add(door);
				//loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('door ' + (xhr.loaded) + '% loaded');
					var prc = Math.floor(xhr.loaded / 3027156 * 100);

				}
			);
			// this centers the glow at the mesh


			var ufoloader = new GLTFLoader(manager);
			ufoloader.load("models/UFO.glb", function (gltf) {
				var ufo = gltf.scene;

				ufo.scale.set(40, 40, 40);

				ufo.position.set(-60, 60, -190);
				ufo.rotation.y = getRadian(-80);
				ufo.rotation.x = getRadian(5);


				ufo.visible = true;



				ufo.traverse(function (o) {
					if (o.isMesh) {
						console.log("UFO");
						if (o.name == 'Light') {
							o.material = new THREE.MeshBasicMaterial({ color: 0xC440FF, opacity: 0.6, transparent: true, });
						}
					}
				});

				scene1.add(ufo);

				var spriteMap = new THREE.TextureLoader().load("glow.png");
				var spriteMaterial = new THREE.SpriteMaterial(
					{
						map: spriteMap, useScreenCoordinates: false,
						color: 0xC440FF, transparent: true, blending: THREE.AdditiveBlending

					});
				var sprite = new THREE.Sprite(spriteMaterial);
				sprite.scale.set(2.5, 2.5, 1.0);
				sprite.position.set(0, 0.3, 0);
				ufo.add(sprite);
				var sprite2 = new THREE.Sprite(spriteMaterial);
				sprite2.scale.set(1.5, 1.5, 1.0);
				sprite2.position.set(0, -0.1, 0);
				ufo.add(sprite2);

				var pLight = new THREE.PointLight(0xC440FF, 8, 140);
				pLight.rotation.x = getRadian(90);
				pLight.position.set(-60, 50, -190);
				scene1.add(pLight);

			},
				// called while loading is progressing
				function (xhr) {

					//console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

				}
			);


			//createDecalFire();


		}

		function initScene2() {

			scene2loaded = true;
			scene2.add(controls.getObject());

			var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 1);
			light.position.set(0.5, 1, 0.75);
			scene2.add(light);

			var light1 = new THREE.PointLight(0xFFFFFF, 10, 140);
			light1.position.set(80, 10, -60);
			//scene2.add( light1 );

			var amblight = new THREE.AmbientLight(0xFFFFFF, 0.3);
			scene2.add(amblight);

			var texture = new THREE.TextureLoader().load("textures/Aurora3.png");
			var material = new THREE.MeshPhongMaterial({ color: 0x02FD01, alphaMap: texture, transparent: true, opacity: 1 });
			material.map = texture;

			material.color = new THREE.Color(0x02FD01);
			material.side = THREE.FrontSide;
			tsph = new THREE.Mesh(new THREE.SphereGeometry(34, 60, 40), material);
			tsph.position.set(-63, -45, -215);
			tsph.name = "Moon";
			scene2.add(tsph);


			var starGeo = new THREE.Geometry();
			for (let i = 0; i < 6000; i++) {
				let star = new THREE.Vector3(
					Math.random() * 300 - 200,
					Math.random() * 600 - 300,
					Math.random() * 600 - 400
				);
				starGeo.vertices.push(star);
			}
			let sprite = new THREE.TextureLoader().load('glow.png');
			let starMaterial = new THREE.PointsMaterial({
				color: 0xaaaaaa,
				size: 0.7,
				map: sprite,
				transparent: true
			});
			var stars = new THREE.Points(starGeo, starMaterial);
			scene2.add(stars);


			//scene2.add(ufo);

			var rocksloader = new GLTFLoader(manager);
			rocksloader.load("models/Space4.glb", function (gltf) {
				rocks = gltf.scene;

				//rocks.scale.set(0.05,0.05,0.05);

				rocks.position.set(0, 10, -250);
				rocks.rotation.y = getRadian(-80);
				rocks.rotation.x = getRadian(10);

				rocks.visible = true;

				rocks.traverse(function (o) {
					if (o.isMesh) {
						//console.log("rocks " + o.name);
						if (o.name == 'FirePlanet') {
							o.scale.set(50, 50, 50);
							o.position.set(80, -30, -50);
							o.material.roughness = 0.9;
							o.material.emissiveMap = o.material.map;

						} else if (o.name == 'Sphere') {
							o.scale.set(600, 600, 600);
						} else if (o.name == "Moon") {
							o.scale.set(30, 30, 30);
							o.position.set(30, -50, 70);
						}
						else if (o.name.includes("Beton")) {

							rocksGeo.push(o.geometry);
							rocksMats.push(o.material);

							switch (o.name) {
								case 'Beton_1':
									o.position.set(160, 15, 110);
									break;
								case 'Beton_2':
									o.position.set(180, 0, -70);
									break;
								case 'Beton_3':
									o.position.set(160, -40, 40);
									break;
								case 'Beton_4':
									o.position.set(-100, 0, 100);
									break;
								case 'Beton_5':
									o.position.set(110, 50, -80);
									break;
							}

							o.scale.set(0.5, 0.5, 0.5);
						}
					}
				});


				var spriteMap = new THREE.TextureLoader().load("glow.png");
				var spriteMaterial = new THREE.SpriteMaterial(
					{
						map: spriteMap, useScreenCoordinates: false,
						color: 0xd31313, transparent: true, blending: THREE.AdditiveBlending

					});
				var sprite = new THREE.Sprite(spriteMaterial);
				sprite.scale.set(126, 126, 1.0);
				sprite.position.set(80, -30, -50);
				rocks.add(sprite);

				var spriteMaterial2 = new THREE.SpriteMaterial(
					{
						map: spriteMap, useScreenCoordinates: false,
						color: 0x1eff00, transparent: true, blending: THREE.AdditiveBlending

					});
				var sprite2 = new THREE.Sprite(spriteMaterial2);
				sprite2.scale.set(80, 80, 1.0);
				sprite2.position.set(30, -50, 70);
				rocks.add(sprite2);


				scene2.add(rocks);
				console.log('rocks added to scene');
				rocksGeo.forEach(makeInstancedRocks);

				loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('rocks ' + (xhr.loaded) + ' loaded');
					var prc = Math.floor(xhr.loaded / 7119612 * 100);

					updateLoadBar(prc);
				}
			);

			var ufoloader = new GLTFLoader(manager);
			ufoloader.load("models/UFOwithout.glb", function (gltf) {
				var ufo = gltf.scene;

				ufo.scale.set(30, 30, 30);

				ufo.position.set(-50, 60, -250);
				ufo.rotation.y = getRadian(-80);
				ufo.rotation.x = getRadian(10);

				ufo.visible = true;

				ufo.traverse(function (o) {
					if (o.isMesh) {
						console.log("UFO");
						if (o.name == "Light") o.material = new THREE.MeshBasicMaterial({ color: 0xC440FF, opacity: 0.2, transparent: true, });
					}
				});
				scene2.add(ufo);

				var spriteMap = new THREE.TextureLoader().load("glow.png");
				var spriteMaterial = new THREE.SpriteMaterial(
					{
						map: spriteMap, useScreenCoordinates: false,
						color: 0xC440FF, transparent: true, blending: THREE.AdditiveBlending

					});
				var sprite = new THREE.Sprite(spriteMaterial);
				sprite.scale.set(2.2, 2.2, 1.0);
				sprite.position.set(0, 0.2, 0);
				ufo.add(sprite);

				var light = new THREE.PointLight(0xFFFFFF, 100, 60);
				light.position.set(-80, 60, -160)
				scene2.add(light);
				var light2 = new THREE.PointLight(0xFFFFFF, 60, 60);
				light2.position.set(30, 60, -210)
				scene2.add(light2);

				console.log('ufo added to scene');
				$("#loadText").html('loaded<br>');
			},
				// called while loading is progressing
				function (xhr) {
					console.log('ufo ' + (xhr.loaded) + ' loaded');
					var prc = Math.floor(xhr.loaded / 2561968 * 100);

				}
			);

			/*
			
			var uniforms = {  
			texture: { type: 't', value: THREE.ImageUtils.loadTexture('textures/Nebula.png') }
			};
			
			var material = new THREE.ShaderMaterial( {  
			uniforms:       uniforms,
			vertexShader:   document.getElementById('sky-vertex').textContent,
			fragmentShader: document.getElementById('sky-fragment').textContent
			});
			*/
			var material = new THREE.MeshBasicMaterial();
			material.map = new THREE.TextureLoader().load("textures/Nebula.png");
			material.color = new THREE.Color(0xFFFFFF);
			material.side = THREE.BackSide;
			var sky = new THREE.Mesh(new THREE.SphereGeometry(500, 60, 40), material);
			sky.rotation.y = getRadian(0);
			scene2.add(sky);

		}

		function initScene3() {

			scene3loaded = true;
			scene3.add(controls.getObject());



			var amblight = new THREE.AmbientLight(0x02FD01, 0.2); // soft white light
			scene3.add(amblight);

			var light2 = new THREE.PointLight(0xFFFFFF, 3, 2000);
			light2.position.set(0.5, 15, 4);
			light2.castShadow = true;
			scene3.add(light2);



			var moonloader = new GLTFLoader(manager);
			moonloader.load("models/moon9.glb", function (gltf) {
				var moon = gltf.scene;

				moon.scale.set(0.8, 0.8, 0.8);

				//moon.position.set(- 160, 6, 80);
				moon.rotation.y = getRadian(-90);

				moon.visible = true;



				moon.traverse(function (o) {
					if (o.isMesh) {
						console.log("moon");
						o.receiveShadow = true;
						//createDecal();

					}
				});
				scene3.add(moon);
			},
				// called while loading is progressing
				function (xhr) {
					console.log('moon ' + (xhr.loaded) + '% loaded');
					var prc = Math.floor(xhr.loaded / 3027156 * 100);

					updateLoadBar(prc);
				}
			);

			var doorloader = new GLTFLoader(manager);
			doorloader.load("models/DoorRetopo4.glb", function (gltf) {
				var door = gltf.scene;
				var plane2;
				door.scale.set(5, 5, 5);

				door.position.set(-30, 0, 0);
				door.rotation.y = getRadian(-45);

				door.visible = true;



				door.traverse(function (o) {
					if (o.isMesh) {
						console.log("door");
						o.castShadow = true;
						if (o.name == "Plane002") {
							//o.rotation.y = getRadian(90);
							//o.rotation.x = getRadian(90);
							plane2 = o;
						} else if (o.name == "Invisible") {
							o.material = new THREE.MeshStandardMaterial({ color: 0x000000 });
						}

					}
				});
				scene3.add(door);

			},
				// called while loading is progressing
				function (xhr) {
					console.log('door ' + (xhr.loaded) + '% loaded');
					var prc = Math.floor(xhr.loaded / 3027156 * 100);

				}
			);

			var geometry = new THREE.BoxGeometry(6, 15, 6);
			//var geo2 = new THREE.BoxGeometry(5, 15, 5);
			var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
			var cube = new THREE.Mesh(geometry, material);
			var cube2 = new THREE.Mesh(geometry, material);
			var cube3 = new THREE.Mesh(geometry, material);
			cube.position.set(15, 8, 10);
			cube2.position.set(-5, 8, -15);
			cube3.position.set(-20, 7, 30);
			cube.visible = false;
			cube2.visible = false;
			cube3.visible = false;
			scene3.add(cube);
			scene3.add(cube2);
			scene3.add(cube3);


			var Statueloader = new GLTFLoader(manager);
			Statueloader.load("models/StatuesAnim3.glb", function (gltf) {
				var Statue = gltf.scene;

				Statue.scale.set(8, 8, 8);

				Statue.position.set(15, 0, 10);
				Statue.rotation.y = getRadian(260);


				Statue.visible = true;

				Statue.traverse(function (o) {

					if (o.isMesh) {
						//console.log(o.name);
						o.castShadow = true;
						//o.rotation.y = getRadian(90);
						//o.rotation.x = getRadian(90);


					}
				});

				mixer = new THREE.AnimationMixer(gltf.scene);
				mixer.clipAction(gltf.animations[0]).play();
				mixer.timeScale = 1.3;

				scene3.add(Statue);

			},
				// called while loading is progressing
				function (xhr) {
					console.log('Statue ' + (xhr.loaded) + 'B loaded');
					var prc = Math.floor(xhr.loaded / 10260068 * 100);

				}
			);

			var Statue2loader = new GLTFLoader(manager);
			Statue2loader.load("models/StatuesAnim2.glb", function (gltf) {
				var Statue2 = gltf.scene;

				Statue2.scale.set(8, 8, 8);

				Statue2.position.set(-5, -0.4, -15);
				Statue2.rotation.y = getRadian(180);

				Statue2.visible = true;

				Statue2.traverse(function (o) {
					if (o.isMesh) {
						//console.log(o.name);
						o.castShadow = true;
						//o.rotation.y = getRadian(90);
						//o.rotation.x = getRadian(90);
					}
				});

				mixer2 = new THREE.AnimationMixer(gltf.scene);
				mixer2.clipAction(gltf.animations[0]).play();
				mixer2.timeScale = 1.3;

				scene3.add(Statue2);

			},
				// called while loading is progressing
				function (xhr) {
					console.log('Statue2 ' + (xhr.loaded) + 'B loaded');
					var prc = Math.floor(xhr.loaded / 10260068 * 100);

				}
			);

			var Statue3loader = new GLTFLoader(manager);
			Statue3loader.load("models/StatuesAnim1.glb", function (gltf) {
				var Statue3 = gltf.scene;

				Statue3.scale.set(8, 8, 8);

				Statue3.position.set(-20, -1.2, 30);
				Statue3.rotation.y = getRadian(-20);

				Statue3.visible = true;

				Statue3.traverse(function (o) {
					if (o.isMesh) {
						//console.log(o.name);
						o.castShadow = true;
						//o.rotation.y = getRadian(90);
						//o.rotation.x = getRadian(90);
					}
				});

				mixer3 = new THREE.AnimationMixer(gltf.scene);
				mixer3.clipAction(gltf.animations[0]).play();
				mixer3.timeScale = 1.3;

				scene3.add(Statue3);
				loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('Statue3 ' + (xhr.loaded) + 'B loaded');
					var prc = Math.floor(xhr.loaded / 10260068 * 100);

				}
			);



			/*
			
			var uniforms = {  
			texture: { type: 't', value: THREE.ImageUtils.loadTexture('textures/Nebula.png') }
			};
			
			var material = new THREE.ShaderMaterial( {  
			uniforms:       uniforms,
			vertexShader:   document.getElementById('sky-vertex').textContent,
			fragmentShader: document.getElementById('sky-fragment').textContent
			});
			*/
			var texture = new THREE.TextureLoader().load("textures/Aurora3.png");
			var material = new THREE.MeshPhongMaterial({ color: 0x000000, alphaMap: texture, transparent: true, opacity: 0.6 });
			var material2 = new THREE.MeshBasicMaterial();
			material2.map = texture;
			material.map = texture;
			material2.side = THREE.BackSide;
			material.color = new THREE.Color(0xFFFFFF);
			material.side = THREE.BackSide;
			gasSphere = new THREE.Mesh(new THREE.SphereGeometry(70, 60, 40), material);
			var tsph = new THREE.Mesh(new THREE.SphereGeometry(90, 60, 40), material2);
			scene3.add(gasSphere);
			scene3.add(tsph);
		}

		function init() {
			//clock = new THREE.Clock();
			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1500);
			camera.position.y = 10;
			camera.position.z = 30;
			scene = new THREE.Scene();

			scene1 = new THREE.Scene();
			scene2 = new THREE.Scene();
			scene3 = new THREE.Scene();

			currentScene = scene2;

			listener = new THREE.AudioListener();
			camera.add(listener);
			// create a global audio source
			sound = new THREE.Audio(listener);

			//ufo = new THREE.Object3D();
			scene.background = new THREE.Color(0x000000);
			//scene1.background = new THREE.Color( 0x000000);
			//scene.fog = new THREE.Fog( 0xffffff, 0, 750 );
			scene1.fog = new THREE.Fog(0x000000, 0, 400);
			scene2.fog = new THREE.Fog(0x000000, 0, 900);
			scene3.fog = new THREE.Fog(0x02FD01, 0, 200);

			var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 2);
			light.position.set(0.5, 3, 0.75);
			scene.add(light);



			controls = new PointerLockControls(camera, document.body);

			var blocker = document.getElementById('blocker');
			var instructions = document.getElementById('instructions');
			var forward = document.getElementById('forward');
			crossHair = document.getElementById('crossHair');
			/*
			var footer = document.getElementById( 'footer' );
			
			footer.addEventListener( 'click', switchScenes, false );
*/

			//party
			var particleMat = new THREE.SpriteMaterial({ map: new THREE.TextureLoader().load('textures/Pill.png'), color: 0xffffff });

			for (var i = 0; i < 100; i++) {

				particle = new Particle3D(particleMat.clone());
				particle.position.x = Math.random() * -60 - 30;
				particle.position.y = Math.random() * 80 - 30;
				particle.position.z = Math.random() * -190 - 80;
				particle.scale.x = 6;
				particle.scale.y = 6;

				scene1.add(particle);

				particles.push(particle);
			}
			var particleSMat = new THREE.SpriteMaterial({ map: new THREE.TextureLoader().load('SomaIcov1.png'), color: 0xffffff });
			for (var i = 0; i < 100; i++) {

				particleS = new Particle3D(particleSMat.clone());
				particle.position.x = Math.random() * -60 - 30;
				particle.position.y = Math.random() * 80 - 30;
				particle.position.z = Math.random() * -190 - 80;
				particleS.scale.x = 10;
				particleS.scale.y = particleS.scale.x;

				scene1.add(particleS);

				particlesS.push(particleS);
			}

			forward.addEventListener('touchstart', function (e) {

				moveForward = true;
				console.log("TOUCHENDD");
				//return;

			}, false);
			forward.addEventListener('touchend', function (e) {

				moveForward = false;
				console.log("TOUCHENDD");
				//return;

			}, false);

			$('#footer a').click(function (e) {
				e.returnValue = false;
				e.preventDefault();

				var txt = $(e.target).text();


				console.log(txt);
				controls.unlock();

				setTimeout(function () { goToScene(txt) }, 1000);
				fadeInstr();
				transition = true;

				//controls.unlock();					
			});


			/*
			
						instructions.addEventListener('click', function () {
			
							if (currentSceneLoaded == true & transition == true) {
								controls.lock();
								if (tutorial == true) {
									playSound("Space");
									tutorial = false;
									$("#clickToEnter").html('');
								}
								transition = false;
							}
			
						}, false);*/
			//body
			document.addEventListener('touchstart', function (e) {
				e.preventDefault();
				e.returnValue = false;
				console.log("touchStart");

				onDocumentMouseDown(e);


			}, false);

			if (isMobile == false) {
				document.addEventListener('mousemove', onDocumentMouseMove, false);
				document.addEventListener('mousedown', onDocumentMouseDown, false);
			} else {
				document.addEventListener('touchmove', onDocumentMouseMove, false);
			}



			controls.addEventListener('lock', function () {

				transition = false;
			});

			controls.addEventListener('unlock', function () {
				//fadeInstr();
				//blocker.style.display = 'block';
				//instructions.style.display = '';

				transition = true;

			});


			document.addEventListener('visibilitychange', function () {
				//document.title = document.visibilityState;
				console.log(document.visibilityState);
				if (document.hidden) {
					sound.pause();
				}
				else {

				}
			});



			var onKeyDown = function (event) {
				if (transition == false) {
					switch (event.keyCode) {


						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true;
							break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							break;

						case 32: // space
							if (canJump === true) velocity.y += 250;
							canJump = false;
							break;

					}
				}
				else {


					moveForward = false;
					moveLeft = false;
					moveBackward = false;
					moveRight = false;
				}

			};

			var onKeyUp = function (event) {

				switch (event.keyCode) {

					case 38: // up
					case 87: // w
						moveForward = false;
						break;

					case 37: // left
					case 65: // a
						moveLeft = false;
						break;

					case 40: // down
					case 83: // s
						moveBackward = false;
						break;

					case 39: // right
					case 68: // d
						moveRight = false;
						break;

				}

			};



			document.addEventListener('keydown', onKeyDown, false);
			document.addEventListener('keyup', onKeyUp, false);



			raycaster = new THREE.Raycaster();
			mouse = new THREE.Vector2();

			raycaster2 = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, - 1, 0), 0, 10);

			//initPaintings();


			initScene2();
			scene2.add(controls.getObject());

			var fireTex = new THREE.TextureLoader().load("./Fire.png");
			fire = new Fire(fireTex);
			fire.scale.set(25, 25, 25);
			fire.position.set(0, 10, -30);
			scene1.add(fire);

			fire2 = new Fire(fireTex);
			fire2.scale.set(25, 25, 25);
			fire2.position.set(-40, 10, -30);
			scene1.add(fire2);

			//fire3 = new Fire(fireTex);
			//fire3.scale.set(40, 40, 40);
			//fire3.position.set(40, 20, -110);
			//scene1.add(fire3);

			//fire4 = new Fire(fireTex);
			//fire4.scale.set(40, 40, 40);
			//fire4.position.set(-80, 20, 60);
			//scene1.add(fire4);

			//fire5 = new Fire(fireTex);
			//fire5.scale.set(40, 40, 40);
			//fire5.position.set(70, 20, 100);
			//scene1.add(fire5);

			fire.name = "Fire";
			fire2.name = "Fire";
			//fire3.name = "Fire";
			//fire4.name = "Fire";
			//fire5.name = "Fire";



			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			//renderer.toneMapping = THREE.ReinhardToneMapping;
			//renderer.toneMappingExposure = 2.3;

			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.BasicShadowMap;
			//renderer.gammaOutput = true;
			//renderer.gammaFactor = 2.2;

			document.body.appendChild(renderer.domElement);


			window.addEventListener('resize', onWindowResize, false);


		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		var randomizeMatrix = function () {

			var position = new THREE.Vector3();
			var rotation = new THREE.Euler();
			var quaternion = new THREE.Quaternion();
			var scale = new THREE.Vector3();

			return function (matrix) {

				position.x = 0;
				position.y = Math.random() * 260 - 130;
				position.z = Math.random() * 260 - 130;

				//rotation.x = Math.random() * 2 * Math.PI;
				//rotation.y = Math.random() * 2 * Math.PI;
				rotation.z = Math.random() * 2 * Math.PI;
				rotation.y = getRadian(90);
				if (isAppleDevice == false) {
					rotation.y = getRadian(90);
					//console.log(rotation);
				} /*else if (isAppleDevice) {
					rotation.x = 0;
					rotation.y = 0;
					rotation.z = 1.57;
					//console.log(rotation);
				}*/
				if (isChrome == false) {
					//rotation.x = getRadian(-90);
					//rotation.y = getRadian(90);
					//rotation.z = getRadian(90);
					//console.log(rotation);
				}


				quaternion.setFromEuler(rotation);
				var max = 0.5;
				var min = 0.1;
				scale.x = scale.y = scale.z = Math.random() * (max - min) + min;


				matrix.compose(position, quaternion, scale);

			};

		}();


		var randomizeMatrixRocks = function () {

			var position = new THREE.Vector3();
			var rotation = new THREE.Euler();
			var quaternion = new THREE.Quaternion();
			var scale = new THREE.Vector3();

			return function (matrix) {

				position.x = Math.random() * 260 - 130;
				position.y = Math.random() * 260 - 130;
				position.z = 0;

				//rotation.x = Math.random() * 2 * Math.PI;
				//rotation.y = Math.random() * 2 * Math.PI;
				rotation.z = Math.random() * 2 * Math.PI;

				rotation.y = getRadian(90);


				quaternion.setFromEuler(rotation);
				var max = 0.5;
				var min = 0.1;
				scale.x = scale.y = scale.z = 0.01;

				matrix.compose(position, quaternion, scale);

			};

		}();

		function createDecal() {

			var huTex = new THREE.TextureLoader().load("textures/Gas.jpg");
			var geometry = new THREE.PlaneGeometry(2, 3, 3);
			var material = new THREE.MeshPhongMaterial({ map: huTex, side: THREE.DoubleSide });
			var plane = new THREE.Mesh(geometry, material);
			plane.position.set(0, 0.3, 0);
			plane.rotation.x = getRadian(-90);
			plane.scale.set(-2, -2, 2);
			scene3.add(plane);

			var huTex2 = new THREE.TextureLoader().load("textures/Gas_.jpg");
			var material2 = new THREE.MeshPhongMaterial({ map: huTex2, side: THREE.DoubleSide, specular: 0, roughness: 1 });
			var plane2 = new THREE.Mesh(geometry, material2);
			plane2.position.set(-10, 0.3, 8);
			plane2.rotation.x = getRadian(90);
			plane2.rotation.z = getRadian(90);
			plane2.scale.set(-2, -2, 2);
			scene3.add(plane2);





		}

		function createDecalFire(mesh) {

			var huTex = new THREE.TextureLoader().load("textures/Feuer.jpg");
			var geometry = new THREE.PlaneGeometry(20, 30, 32);
			var material = new THREE.MeshPhongMaterial({ color: 0xffffff, alphaMap: huTex, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
			var plane = new THREE.Mesh(geometry, material);
			plane.position.set(30, 30, -35);

			plane.scale.set(2, 2, 2);
			scene1.add(plane);

			var huTex2 = new THREE.TextureLoader().load("textures/Feuer_.jpg");
			var geometry2 = new THREE.PlaneGeometry(20, 30, 32);
			var material2 = new THREE.MeshPhongMaterial({ color: 0xffffff, alphaMap: huTex2, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
			var plane2 = new THREE.Mesh(geometry, material2);
			plane2.position.set(20, 30, 95);
			plane2.scale.set(2, 2, 2);
			scene1.add(plane2);

		}


		function makeInstanced(geometry, material) {
			var count = 360;
			var matrix = new THREE.Matrix4();
			var mesh = new THREE.InstancedMesh(geometry, material, count);

			for (var i = 0; i < count; i++) {

				randomizeMatrix(matrix);
				mesh.setMatrixAt(i, matrix);

			}
			mesh.rotation.z = getRadian(90);
			mesh.position.set(0, -1, 0);
			scene1.add(mesh);

		}

		function makeInstancedRock(geometry, material, i) {
			var count = 1;
			var matrix = new THREE.Matrix4();
			var mesh = new THREE.InstancedMesh(geometry, material, count);

			var position = new THREE.Vector3();
			var rotation = new THREE.Euler();

			var quaternion = new THREE.Quaternion();
			var scale = new THREE.Vector3();

			switch (i) {
				case 0:

					position.x = -20;
					position.y = 0;
					position.z = 15;

					rotation.x = 90;
					rotation.y = 0;
					rotation.z = 0;

					break;
				case 1:
					position.x = -15;
					position.y = 1;
					position.z = -10;

					rotation.x = 0;
					rotation.y = 0;
					rotation.z = 10;
					break;
				case 2:
					position.x = 15;
					position.y = 0;
					position.z = 20;

					rotation.x = 0;
					rotation.y = 0;
					rotation.z = 90;
					break;
				case 3:
					position.x = 0;
					position.y = 0;
					position.z = -20;

					rotation.x = 0;
					rotation.y = 0;
					rotation.z = 0;
					break;
				case 4:
					position.x = -15;
					position.y = 0;
					position.z = 20;

					rotation.x = 0;
					rotation.y = 0;
					rotation.z = 30;
					break;
			}
			rotation.x = -80;

			quaternion.setFromEuler(rotation);
			var max = 0.05;
			var min = 0.01;
			scale.x = scale.y = scale.z = 0.1;


			matrix.compose(position, quaternion, scale);

			mesh.setMatrixAt(0, matrix);

			//mesh.scale.set(1,1,1);
			//mesh.rotation.x = getRadian(90);
			mesh.position.set(0, -0.2, 0);
			//mesh.castShadow = true;
			scene3.add(mesh);
			//scene1.add(mesh);

		}

		function makeInstancedRocks(item, i) {
			makeInstancedRock(rocksGeo[i], rocksMats[i], i);
		}

		function rotateDoor(vectorToAnimate, target, options) {
			var speed = 3000;
			// create the tween
			var tween = new TWEEN.Tween(vectorToAnimate).to(target, speed)
				.easing(TWEEN.Easing.Quintic.Out)
				.onComplete(function () {
				});
			tween.onUpdate(function () {
				//console.log(vectorToAnimate);
				options.rotation.y = vectorToAnimate.y;
			});
			// start the tween
			tween.start();
		}

		function moveCamera(vectorToAnimate, target, options) {
			var speed = 4000;
			// create the tween
			var tween = new TWEEN.Tween(vectorToAnimate).to(target, speed)
				.easing(TWEEN.Easing.Quintic.Out)
				.onComplete(function () {
				});
			tween.onUpdate(function () {
				//console.log(vectorToAnimate);
				options.position.z = vectorToAnimate.z;
				options.position.x = vectorToAnimate.x;
			});
			// start the tween
			tween.start();
		}


		var hoverNowName, hoverNowObj;

		function onDocumentMouseMove(event) {
			event.preventDefault();
			event.returnValue = false;
			//mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			//mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

			mouse.x = 0;
			mouse.y = 0;



			raycaster.setFromCamera(mouse, camera);
			var intersects = raycaster.intersectObjects(currentScene.children, true);

			if (intersects.length > 0) {
				//console.log("hover" + oName);
				var oName = intersects[0].object.name;
				if (oName == "Fire" && intersects.length > 1) oName = intersects[1].object.name;

				var intObj = raycaster.in
				if (oName == "FirePlanet" || oName == "Ship" || oName == "Emmisive" || oName == "Moon" || oName == "Plane002" || oName == "Invisible") {
					crossHair.style.display = 'block';
					if ((oName == "Plane002") && getEuler(intersects[0].object.rotation.y) == 0) {
						var vec = { x: 0, y: 0, z: 0 };
						rotateDoor(vec, { x: 0, y: getRadian(index == 1 ? 60 : -70), z: 0 }, intersects[0].object);

						hoverNowName = oName;
						hoverNowObj = intersects[0].object;
					}

				}
				else {
					crossHair.style.display = 'none';
					if (hoverNowName == "Plane002" || hoverNowName == "Invisible") {

						var vec = { x: 0, y: getRadian(index == 1 ? 60 : -70), z: 0 };
						//rotateDoor(vec, { x: 0, y: 0, z: 0 }, hoverNowObj);
					}
					hoverNowName = null;
					hoverNowObj = null;
				}

				$('html,body').css('cursor', 'default');
			} else {
				crossHair.style.display = 'none';
				$('html,body').css('cursor', 'default');

			}


		}


		function onDocumentMouseDown(event) {
			var e = event;
			//if (e.stopPropagation) e.stopPropagation();
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			e.returnValue = false;
			console.log("mouseDown");

			if (currentSceneLoaded == true & transition == true & canClick == true & (blocker.className == "fade" || tutorial == true)) {
				controls.lock();
				fadeInstr();
				if (tutorial == true) {
					playSound("Space");
					tutorial = false;
					$("#clickToEnter").html('');
					footer.style.display = 'block';
					moveCamera({ x: 0, y: 0, z: 400 }, { x: 0, y: 0, z: 30 }, camera);
				}
				transition = false;
				return;
			}


			if (blocker.style.display == 'block') {
				//initTrans();
				return;
			}
			if (isMobile == false) {
				mouse.x = 0;
				mouse.y = 0;
			} else {
				mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.touches[0].clientY / window.innerHeight) * 2 + 1;
			}




			raycaster.setFromCamera(mouse, camera);
			var intersects = raycaster.intersectObjects(currentScene.children, true);
			var to;

			var o;
			o = intersects[0].object;
			if (o.name == "Fire" && intersects.length > 1) o = intersects[1].object;
			if (intersects.length > 0) {

			}
			if (intersects.length > 0) {
				if (transition == false & tutorial == false/* && blocker.style.display == 'none'*/) clicker(o);
				//lightbox_open();
				//animateMove(camera.position,{x: to.position.x - 2, y: to.position.y,z: to.position.z + 0.5},to.position,1000);
				console.log("click");
			}
		}

		function fadeInstr(v) {
			instructions.classList.toggle('fade');
			blocker.classList.toggle('fade');
			if (v != null & false) {
				blocker.style.backgroundColor = v;
			}
		}

		function clicker(o) {
			console.log(o.name);
			moveForward = false;

			moveLeft = false;

			moveBackward = false;

			moveRight = false;
			velocity.z = 0;
			velocity.x = 0;
			$("#loadText").html('  LOADING<div id="clickToEnter" > </div>');
			switch (o.name) {
				case "FirePlanet":
					//goToScene("Fire");
					fadeInstr('black');
					setTimeout(function () { goToScene("Fire") }, 1000);
					controls.unlock();
					canClick = false;
					setTimeout(function () { canClick = true; resetVelocity(); }, 2000);
					//blocker.style.display = 'block';
					//instructions.style.display = 'block';
					transition = true;
					break;
				case "Ship":
					fadeInstr('pink');
					setTimeout(function () { goToScene("UFO") }, 1000);
					//blocker.style.backgroundColor = rgba(1,1,1,1);
					//goToScene("UFO");

					controls.unlock();

					canClick = false;
					setTimeout(function () { canClick = true; resetVelocity(); }, 2000);
					//blocker.style.display = 'block';
					//instructions.style.display = 'block';
					transition = true;
					break;
				case "Emmisive":
					fadeInstr('pink');
					setTimeout(function () { goToScene("UFO") }, 1000);
					controls.unlock();

					canClick = false;
					setTimeout(function () { canClick = true; resetVelocity(); }, 2000);
					//blocker.style.display = 'block';
					//instructions.style.display = 'block';
					transition = true;
					break;
				case "Moon":
					fadeInstr('green');
					setTimeout(function () { goToScene("AtomGas") }, 1000);
					controls.unlock();

					canClick = false;
					setTimeout(function () { canClick = true; resetVelocity(); }, 2000);
					//blocker.style.display = 'block';
					//instructions.style.display = 'block';
					transition = true;
					break;
				case 'Invisible':
				case "Plane002":
					fadeInstr("green");
					if (index == 1) {
						setTimeout(function () { goToScene("AtomGas") }, 1000);

					} else if (index == 3) {
						setTimeout(function () { goToScene("Fire") }, 1000);

					} else if (index == 0) {
						setTimeout(function () { goToScene("AtomGas") }, 1000);

					}
					canClick = false;
					setTimeout(function () { canClick = true; resetVelocity(); }, 2000);
					controls.unlock();
					transition = true;
					break;
			}

		}

		function resetVelocity() {
			velocity.z = 0;
			velocity.x = 0;
		}



		var t = 0;

		function animate() {

			requestAnimationFrame(animate);
			TWEEN.update();
			///party
			for (var i = 0; i < particles.length; i++) {

				var particle = particles[i];
				particle.updatePhysics();
				var p = particle.position;
				particle.material.rotation += randomRange(-0.1, 0.1);
				if (p.y < -20) {
					particle.position.y = 60;
					particle.position.x = -60;
					particle.position.z = -190;
				}
				if (p.x > 500) particle.position.x -= 500;
				else if (p.x < -500) particle.position.x += 500;
				if (p.z > 500) particle.position.z -= 500;
				else if (p.z < -500) particle.position.z += 500;


			}
			for (var i = 0; i < particlesS.length; i++) {

				var particle = particlesS[i];
				particle.updatePhysics();
				var p = particle.position;
				particle.material.rotation += randomRange(-0.1, 0.1);
				if (p.y < -20) {
					particle.position.y = 60;
					particle.position.x = -60;
					particle.position.z = -190;
				}
				if (p.x > 500) particle.position.x -= 500;
				else if (p.x < -500) particle.position.x += 500;
				if (p.z > 500) particle.position.z -= 500;
				else if (p.z < -500) particle.position.z += 500;


			}





			/*
						t = t + 0.01;
						if (index == 1) {
							fireAnim.update(t);
							//fire.update(t);
							//fire2.update(t);
							//fire3.update(t);
							//fire4.update(t);
							//fire5.update(t);
						}
			*/
			if (rocks != null && index == 2) rocks.traverse(function (o) {
				if (o.isMesh & o.name.includes("Beton")) {

					switch (o.name) {
						case 'Beton_1':
							o.rotation.x -= 0.0009;
							o.rotation.z += 0.0008;
							break;
						case 'Beton_2':
							o.rotation.y += 0.0002;
							o.rotation.z -= 0.00014;
							break;
						case 'Beton_3':
							o.rotation.x += 0.0009;
							o.rotation.y += 0.00015;
							break;
						case 'Beton_4':
							o.rotation.x += 0.0009;
							o.rotation.z -= 0.0008;
							break;
						case 'Beton_5':
							o.rotation.x -= 0.00011;
							o.rotation.y -= 0.0008;
							break;
					}
				}
			});
			if (gasSphere != null && index == 3) {
				//gasSphere.rotation.x -= 0.0008;
				gasSphere.rotation.y -= 0.001;
			}
			if (tsph != null && index == 2) {
				tsph.rotation.x -= 0.0008;
				tsph.rotation.y -= 0.002;
			}
			if (controls.isLocked != true) {
				resetVelocity();

			}
			//console.log(velocity);
			if (controls.isLocked === true) {





				//raycaster.ray.origin.copy(controls.getObject().position);
				//raycaster.ray.origin.y -= 10;

				//var intersections = raycaster.intersectObjects(objects);

				var onObject = false; //intersections.length > 0;

				var time = performance.now();
				var delta = (time - prevTime) / 1000;

				if (index == 3) {
					if (mixer) mixer.update(delta);
					if (mixer2) mixer2.update(delta);
					if (mixer3) mixer3.update(delta);
				}

				velocity.x -= velocity.x * 10.0 * delta;
				velocity.z -= velocity.z * 10.0 * delta;

				velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

				direction.z = Number(moveForward) - Number(moveBackward);
				direction.x = Number(moveRight) - Number(moveLeft);
				direction.normalize(); // this ensures consistent movements in all directions

				if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
				if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

				//console.log(velocity);

				if (index == 1) {
					fireAnim.update(1000 * delta);
					//fire.update(t);
					//fire2.update(t);
					//fire3.update(t);
					//fire4.update(t);
					//fire5.update(t);
				}

				raycaster2.setFromCamera(mouse, camera);

				//raycaster2.ray.origin.copy(controls.getObject().position);
				//raycaster2.ray.origin.x -= 10;

				var intersects2 = raycaster2.intersectObjects(currentScene.children, true);
				if (intersects2.length > 0 & velocity.z < 0) {
					if (intersects2[0].object.name != "Fire" & intersects2[0].object.name != 'Aset_cement_rubble_S_riuvL_LOD4') {
						console.log("MoveForwardBLock ");
						velocity.z = 0;
						velocity.x = 0;
						//return;
						if (intersects2[0].object.name == "Invisible") {
							if (index == 1) {
								setTimeout(function () { goToScene("AtomGas") }, 1000);

							} else if (index == 3) {
								setTimeout(function () { goToScene("Fire") }, 1000);

							} else if (index == 0) {
								setTimeout(function () { goToScene("AtomGas") }, 1000);

							}
							canClick = false;
							setTimeout(function () { canClick = true; resetVelocity(); }, 2000);
							fadeInstr("green");
							controls.unlock();
							transition = true;
						}
					}
				}

				controls.moveRight(- velocity.x * delta);
				controls.moveForward(- velocity.z * delta);


				controls.getObject().position.y += (velocity.y * delta); // new behavior

				if (controls.getObject().position.y < 10) {

					velocity.y = 0;
					controls.getObject().position.y = 10;

					canJump = false;

				}

				prevTime = time;

			} else {

				direction.x = 0;
				direction.y = 0;
				velocity.y = 0;
				velocity.x = 0;
				moveForward = false;
			}

			renderer.render(currentScene, camera);
			//composer.render();
		}


		function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) {
			// note: texture passed by reference, will be updated by the update function.

			this.tilesHorizontal = tilesHoriz;
			this.tilesVertical = tilesVert;
			// how many images does this spritesheet contain?
			//  usually equals tilesHoriz * tilesVert, but not necessarily,
			//  if there at blank tiles at the bottom of the spritesheet. 
			this.numberOfTiles = numTiles;
			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set(1 / this.tilesHorizontal, 1 / this.tilesVertical);

			// how long should each image be displayed?
			this.tileDisplayDuration = tileDispDuration;

			// how long has the current image been displayed?
			this.currentDisplayTime = 0;

			// which image is currently being displayed?
			this.currentTile = 0;

			this.update = function (milliSec) {
				this.currentDisplayTime += milliSec;
				while (this.currentDisplayTime > this.tileDisplayDuration) {
					this.currentDisplayTime -= this.tileDisplayDuration;
					this.currentTile++;
					if (this.currentTile == this.numberOfTiles)
						this.currentTile = 0;
					var currentColumn = this.currentTile % this.tilesHorizontal;
					texture.offset.x = currentColumn / this.tilesHorizontal;
					var currentRow = Math.floor(this.currentTile / this.tilesHorizontal);
					texture.offset.y = currentRow / this.tilesVertical;
				}
			};
		}

	</script>

	<audio id="audio" src="Sound/Space.ogg"></audio>


	<div id="footer">

		<a>Space</a> <a>Fire</a> <a>UFO</a> <a>AtomGas</a>

	</div>

	<div id="forward">
	</div>

</body>

</html>