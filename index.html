<!DOCTYPE html>
<html lang="en">

<head>
	<title>Ballaballismus by Nessi Nezzila</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="examples/main.css">

	<meta name="description" content="Virtual Exhibition">
	<meta name="author" content="Nessi Nezilla & NotReal_Virtual">

	<meta property="og:title" content="Ballaballismus by Nessi Nezzila">
	<meta property="og:image" content="textures/meta.png">
	<meta property="og:description" content="Virtual Exhibition">

	<link rel='shortcut icon' href='favicon.ico' type='image/png' />
	<link rel="icon" sizes="192x192" href="favicon.ico">
	<link rel="manifest" href="mani.webmanifest" />

	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.3.5/Tween.min.js"></script>

	<style type="text/css">
		.ldBar path.mainline {
			stroke-width: 10;
			stroke: #f1f2f3;
		}

		.ldBar path.baseline {
			stroke-width: 18;
			stroke: #272727;
		}

		#myProgress {
			width: 100%;
			background-color: black;


			position: absolute;
			bottom: 30%;

		}

		#simple {
			position: fixed;
			right: 10px;
			bottom: 0;
			width: 100%;
			font-family: customFont;
			text-align: right;
			font-size: 18px;
			margin-bottom: 10px;
			line-height: 1.3;

			
		}

		#credits {
			position: fixed;
			left: 0;
			top: 0;
			width: 100%;
			font-family: customFont;
			text-align: left;
			font-size: 18px;
			margin-top: 10px;
			padding-left: 10px;
			margin-right: 10px;
			line-height: 1.1;
		}

		#myBar {
			width: 1%;
			height: 0px;
			background-color: rgb(248, 47, 255);


		}

		#crossHair {
			width: 2%;
			top: 50%;
			left: 50%;
			position: absolute;
			margin-right: -50%;
			transform: translate(-50%, -50%);
			display: none;
		}

		#loadText {
			font-size: 42px;
			position: absolute;
			line-height: 1.5;
			top: 30%;
			left: 0;
			right: 0;

			/* Create the gradient. 
			background-color: #CA4246;
			background-image: linear-gradient(0deg,
					rgb(248, 47, 255) 90.666%,
					#ffffff 10.333%);


			/* Set the background size and repeat properties. 
			background-size: 100%;
			background-repeat: repeat;

			/* Use the text as a mask for the background. 
			/* This will show the gradient as a text color rather than element bg.
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;*/
		}

		#instructions {
			line-height: 1.2;
			opacity: 1;
			transition: opacity 1s;
		}

		#instructions.fade {
			opacity: 0;
		}

		#blocker {
			opacity: 1;
			transition: opacity 1s;
			z-index: 10;
		}

		#blocker.fade {
			opacity: 0;
			z-index: 0;
		}

		#clickToEnter {
			font-size: 42px;
			cursor: pointer;
			-webkit-animation: colorpulse 4s infinite alternate;
			animation: colorpulse 4s infinite alternate;
			line-height: 1;
		}

		@-webkit-keyframes colorpulse {
			0% {
				color: #009e85;
			}

			25% {
				color: #ea309c;
			}

			50% {
				color: #f59c0d;
			}

			75% {
				color: #2482b9;
			}
		}

		@keyframes colorpulse {
			0% {
				color: #009e85;
			}

			25% {
				color: #ea309c;
			}

			50% {
				color: #f59c0d;
			}

			75% {
				color: #2482b9;
			}
		}

		@keyframes rotation {
			from {
				transform: rotate(0deg);
			}

			to {
				transform: rotate(359deg);
			}
		}

		#forward {

			position: fixed;
			z-index: 8;
			right: 2%;
			margin-bottom: 10px;
			cursor: pointer;
			bottom: 0;
			width: 232px;
			height: 137px;
			background-image: url("textures/ArrowsPink.png");
			background-size: 100% 100%;

			-webkit-user-select: none;
			-khtml-user-select: none;
			-moz-user-select: none;
			-o-user-select: none;
			user-select: none;
			touch-action: none;


		}

		#size {
			width: 100%;
			position: fixed;
			font-size: 38px;
			height: 50px;
			top: 40px;
			opacity: 0;
			transition: opacity 0.3s;
			text-align: center;
		}

		#size.fade {
			opacity: 1;
			-webkit-animation: colorpulse 4s infinite alternate;
			animation: colorpulse 4s infinite alternate;
		}
	</style>

</head>

<body>
	<img src="textures/mouse.png" id="crossHair">
	<div id="blocker">

		<div id="instructions">
			<div>
				<span id='loadText'>Loading...</span>
			</div>
			<div id="myProgress">
				<div id="myBar"></div>
			</div>
			<br><br><br>
			<br>
			<br>
			<img src='textures/TutorialO.jpg' style="width: 180px; height: 90px;" />
			<br>

			</br></br>
			</br></br>
			<div id="simple">
				Works Best On NEW DEVICES<br>
				If it Doesnt Work <a href="http://exhibition.Nessi-Nezilla.de/360.html">Click Here</a>
			</div>
			<div id="credits">
				Nessi Nezilla - ballaballa <br> Lucas Saidl & Sebastian Zimmerhackl - virtual Reality <br> Nils Lesser - Sound
			</div>
		</div>

	</div>
	<audio loop id="music" preload="auto" style="display: none">
		<source src="Sound/Space.mp3" type="audio/mpeg">
	</audio>
	<div id="size">
		100 X 300
	</div>

	<script type="module">
		//(function () { var script = document.createElement('script'); script.onload = function () { var stats = new Stats(); document.body.appendChild(stats.dom); requestAnimationFrame(function loop() { stats.update(); requestAnimationFrame(loop) }); }; script.src = '//mrdoob.github.io/stats.js/build/stats.min.js'; document.head.appendChild(script); })()
		import * as THREE from './build/three.module.js';
		import { PointerLockControls } from './examples/jsm/controls/PointerLockControls.js';
		import { GLTFLoader } from './examples/jsm/loaders/GLTFLoader.js';
		import {
			Euler,
			EventDispatcher,
			Vector3
		} from "./build/three.module.js";

		var isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
		if (isMobile == false) {
			$("#forward").css("height", "0px");
			$("#footer").css("display", "none");
			$("#footer").html("");
		} else {

		}
		var isAppleDevice = navigator.userAgent.includes('Macintosh');
		var isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
		console.log("isAPPLE DEVICE = " + isAppleDevice, 'isChrome ' + isChrome, 'isMobile  ' + isMobile);

		var camera, scene, scene1, scene2, scene3, renderer, controls;

		var mixer, mixer2, mixer3;
		var tutorial = true;
		var transition = true;
		var canClick = true;
		var rocks, door, gasSphere, tsph;
		var currentScene;
		var currentSceneLoaded = false;
		var index = 2;
		var scene0loaded = false;
		var scene1loaded = false;
		var scene2loaded = true;
		var scene3loaded = false;
		var fireAnim;
		var listener, sound;

		var rocksMgr, interMgr, bildsMgr, resMgr, stat1Mgr, stat2Mgr, stat3Mgr, moonMgr, babMgr;

		//Party
		var TO_RADIANS = Math.PI / 180;
		var particle;
		var particles = [];
		var particleS;
		var particlesS = [];
		var Particle3D = function (material) {
			THREE.Sprite.call(this, material);
			//this.material = material instanceof Array ? material : [ material ];
			// define properties
			this.velocity = new THREE.Vector3(0, -0.4, 0);
			this.velocity.rotateX(randomRange(-45, 45));
			this.velocity.rotateY(randomRange(0, 360));
			this.gravity = new THREE.Vector3(0, 0, 0);

			this.drag = 1;
			// methods...
		};
		Particle3D.prototype = new THREE.Sprite();
		Particle3D.prototype.constructor = Particle3D;
		Particle3D.prototype.updatePhysics = function () {
			this.velocity.multiplyScalar(this.drag);
			this.velocity.add(this.gravity);
			this.position.add(this.velocity);
		}
		THREE.Vector3.prototype.rotateY = function (angle) {
			var cosRY = Math.cos(angle * TO_RADIANS);
			var sinRY = Math.sin(angle * TO_RADIANS);

			var tempz = this.z;;
			var tempx = this.x;

			this.x = (tempx * cosRY) + (tempz * sinRY);
			this.z = (tempx * -sinRY) + (tempz * cosRY);
		}
		THREE.Vector3.prototype.rotateX = function (angle) {
			var cosRY = Math.cos(angle * TO_RADIANS);
			var sinRY = Math.sin(angle * TO_RADIANS);

			var tempz = this.z;;
			var tempy = this.y;

			this.y = (tempy * cosRY) + (tempz * sinRY);
			this.z = (tempy * -sinRY) + (tempz * cosRY);
		}
		THREE.Vector3.prototype.rotateZ = function (angle) {
			var cosRY = Math.cos(angle * TO_RADIANS);
			var sinRY = Math.sin(angle * TO_RADIANS);

			var tempx = this.x;;
			var tempy = this.y;

			this.y = (tempy * cosRY) + (tempx * sinRY);
			this.x = (tempy * -sinRY) + (tempx * cosRY);
		}
		// returns a random number between the two limits provided
		function randomRange(min, max) {
			return ((Math.random() * (max - min)) + min);
		}
		//Party End


		var crossHair;
		var objects = [];
		var rocksGeo = [];
		var rocksMats = [];
		var raycaster, raycaster2;
		var mouse;
		var clock;
		var moveForward = false;
		var moveBackward = false;
		var moveLeft = false;
		var moveRight = false;
		var canJump = false;
		var prevTime = performance.now();
		var velocity = new THREE.Vector3();
		var direction = new THREE.Vector3();
		var vertex = new THREE.Vector3();
		var color = new THREE.Color();

		var manager = new THREE.LoadingManager();
		manager.onProgress = function (item, loaded, total) {
			//console.log(loaded, total);
		};
		manager.onLoad = function () {
			//console.log('all items loaded');
		};
		manager.onError = function () {
			console.log('there has been an error');
		};

		var elem = document.getElementById("myBar");
		var loading = document.getElementById("myProgress");


		init();
		animate();



		function getRadian(x) {
			return (Math.PI * x) / 180;
		}
		function getEuler(x) {
			return x * (180 / Math.PI);
		}

		function initEnv() {
			var geometry = new THREE.BoxGeometry(1400, 200, 2);
			var material = new THREE.MeshLambertMaterial({ color: 0x111111 });
			var cube = new THREE.Mesh(geometry, material);
			cube.position.set(100, 20, -103);
			//scene.add(cube);

			var light = new THREE.PointLight(0xFFFFFF, 1, 200);
			light.position.set(10, 35, 30);
			scene.add(light);
		}

		function initUfo() {

			scene0loaded = true;

			initEnv();

			loadScene0();

			var doorloader = new GLTFLoader(manager);
			doorloader.load("models/DoorRetopo4.glb", function (gltf) {
				var door = gltf.scene;

				door.scale.set(3, 3, 3);

				door.position.set(-55, 1, 5);
				door.rotation.y = getRadian(-30);

				door.visible = true;

				door.traverse(function (o) {
					if (o.isMesh) {
						console.log("door");
						if (o.name == "Invisible") {
							o.material = new THREE.MeshStandardMaterial({ color: 0x000000 });
						}

					}
				});
				scene.add(door);
				//loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('door ' + (xhr.loaded) + '% loaded');
					var prc = Math.floor(xhr.loaded / 3027156 * 100);

				}
			);


		}
		function loadScene0() {
			interMgr = new ResourceTracker();
			const trackInter = interMgr.track.bind(interMgr);
			var intloader = new GLTFLoader(manager);
			intloader.load("models/interiorPA.glb", function (gltf) {
				var int = trackInter(gltf.scene);

				int.scale.set(12, 12, 12);

				int.position.set(- 0, 0.50, 30);
				int.rotation.y = getRadian(-90);

				//var floorMaterial = new THREE.MeshStandardMaterial({ side: THREE.DoubleSide, color: 0x000000, roughness: 0, specular: 0 });
				int.traverse(function (o) {
					if (o.isMesh) {
						console.log("interrior");
						if (o.name == 'Walls') {
							//o.material = floorMaterial;
						} else if (o.name == "PlaneTop") {
							var huTex = new THREE.TextureLoader().load("textures/UFO.png");
							var huMat = new THREE.MeshPhongMaterial({ map: huTex, transparent: true, opacity: 1, side: THREE.DoubleSide });
							o.material = huMat;
							/*
							var p = o.clone();
							p.position.set(0,2,30);
							p.scale.set(40,40,40);
							scene.add(p);
							*/
						}
					}
				});
				scene.add(int);
				loaded();
			},
				// called while loading is progressing
				function (xhr) {
					var prc = Math.floor(xhr.loaded / 6275116 * 100);
					console.log('interior ' + xhr.loaded + ' loaded');

					updateLoadBar(prc);
				}
			);

			babMgr = new ResourceTracker();
			const trackBab = babMgr.track.bind(babMgr);
			var babyloader = new GLTFLoader(manager);
			babyloader.load("models/Puppe1R.glb", function (gltf) {
				var baby = trackBab(gltf.scene);
				var z = 0;
				baby.scale.set(7, 7, 7);

				baby.position.set(- 0, 1, 30);
				baby.rotation.y = getRadian(-90);

				baby.visible = true;

				baby.traverse(function (o) {
					if (o.isMesh) {
						console.log("babyerrior");
						o.material.spaculer = 1;
					}
				});
				scene.add(baby);
				//loaded();
			},
				// called while loading is progressing
				function (xhr) {
					//var prc = Math.floor(xhr.loaded / 25107276 * 100);
					console.log('babyerior ' + xhr + ' loaded');

					//updateLoadBar(prc);
				}
			);
		}

		function updateLoadBar(prc) {
			elem.style.width = prc + "%";
			$("#loadText").html('loading<br>' + prc + '%<br>');
			$('html,body').css('cursor', 'default');
			/*
			if (prc == 100) loading.style.display = 'none';
			else loading.style.display = 'block';
			*/
		}

		function loaded() {
			currentSceneLoaded = true;
			if (tutorial == true) {
				$("#loadText").html('<div id="clickToEnter" > </div>');
				$("#clickToEnter").html('click To Enter');
				//tutorial = false;
				$('html,body').css('cursor', 'pointer');

			} else {
				$("#loadText").html('loaded');
				$('html,body').css('cursor', 'pointer');
				controls.lock();
				fadeInstr();
				tripCamera({ x: 10, y: 0, z: 0 }, { x: 60, y: 0, z: 0 }, camera, false);
				transition = false;
				//instructions.style.display = 'none';
				//blocker.style.display = 'none';
				//instructions.classList.toggle('fade');
				//blocker.classList.toggle('fade');
			}

		}


		function goToScene(txt) {
			currentSceneLoaded = false;
			console.log("go To Scene" + txt);
			camera.position.z = 30;
			camera.position.x = 5;
			var euler = new Euler(0, 0, 0, 'YXZ');
			camera.quaternion.setFromEuler(euler);
			switch (index) {
				case 0:
					interMgr.dispose();
					babMgr.dispose();
					break;
				case 1:
					resMgr.dispose();
					bildsMgr.dispose();
					//scene1 = new THREE.Scene();
					break;
				case 2:
					rocksMgr.dispose();
					break;
				case 3:
					stat3Mgr.dispose();
					stat2Mgr.dispose();
					stat1Mgr.dispose();
					moonMgr.dispose();
					break;
			}
			playSound(txt);
			switch (txt) {
				case "Space":
					index = 2;
					if (scene2loaded == false) {
						updateLoadBar(0);
						initScene2();
					} else { loadScene2(); updateLoadBar(0); }

					currentScene = scene2;
					break;
				case "Fire":
					index = 1;
					if (scene1loaded == false) {
						updateLoadBar(0);
						initScene1();
					} else { loadScene1(); updateLoadBar(0); }
					currentScene = scene1;
					break;
				case "UFO":
					index = 0;
					if (scene0loaded == false) {
						initScene0();
						updateLoadBar(0);
					} else { loadScene0(); updateLoadBar(0); }
					currentScene = scene;
					break;
				case "AtomGas":
					index = 3;
					if (scene3loaded == false) {
						initScene3();
						updateLoadBar(0);
					} else { loadScene3(); updateLoadBar(0); }
					currentScene = scene3;
					break;
				default:
					switchScenes();
			}

			currentScene.add(controls.getObject());

		}

		function playSound(txt) {
			// load a sound and set it as the Audio object's buffer
			/*
			var audioLoader = new THREE.AudioLoader();
			audioLoader.load('Sound/' + txt + '.ogg', function (buffer) {
				sound.pause();
				// how to reset?
				sound.setBuffer(buffer);
				sound.setLoop(true);
				sound.setVolume(0.6);
				sound.play();
			});
			*/
			var audio = document.getElementById('music');
			//audio.pause();
			//$("#music").html('<source src="Sound/' + txt + '.ogg" type="audio/ogg"><source src="Sound/' + txt + '.mp3" type="audio/mpeg">');
			audio.src = 'Sound/' + txt + '.mp3';
			audio.play();
		}

		function switchScenes() {
			camera.position.y = 10;
			camera.position.z = 30;
			console.log("switch scenes");
			if (currentScene == scene) {
				if (scene1loaded == false) initScene1();
				currentScene = scene1;
			} else if (currentScene == scene1) {
				if (scene2loaded == false) initScene2();
				currentScene = scene2;
			}
			else if (currentScene == scene2) {
				if (scene3loaded == false) initScene3();
				currentScene = scene3;
			}
			else { currentScene = scene; }
		}

		function initScene0() {
			initUfo();
		}

		function initScene1() {
			//scene1.add(controls.getObject());
			scene1loaded = true;

			var floorGeometry = new THREE.PlaneBufferGeometry(2000, 2000, 100, 100);
			floorGeometry.rotateX(- Math.PI / 2);
			var floorMaterial = new THREE.MeshLambertMaterial({ side: THREE.DoubleSide, color: 0x000000 });
			var floor = new THREE.Mesh(floorGeometry, floorMaterial);
			scene1.add(floor);

			var amblight = new THREE.AmbientLight(0xFFFFFf, 0.1);
			scene1.add(amblight);

			//var light = new THREE.HemisphereLight(0xeeeeff, 0.3, 0.75);
			//light.position.set(0.5, 1, 0.75);
			//scene1.add(light);

			var ufolight = new THREE.PointLight(0xeeeeff, 40, 50);
			ufolight.position.set(-80, 55, -100);
			scene1.add(ufolight);
			var ufolight2 = new THREE.PointLight(0xeeeeff, 40, 50);
			ufolight2.position.set(30, 70, -120);
			scene1.add(ufolight2);

			var light2 = new THREE.PointLight(0xf9c59d, 2, 80);
			light2.position.set(0, 25, 30);
			scene1.add(light2);


			var light4 = new THREE.PointLight(0xd31313, 7, 26);
			light4.position.set(-50, 6, -8);
			scene1.add(light4);

			var light5 = new THREE.PointLight(0xd31313, 5, 26);
			light5.position.set(10, 6, 66);
			scene1.add(light5);

			var light6 = new THREE.PointLight(0xd31313, 5, 26);
			light6.position.set(-30, 6, 20);
			scene1.add(light6);


			var light3 = new THREE.PointLight(0xd31313, 5, 26);
			light3.position.set(0, 15, -30);
			scene1.add(light3);



			var runnerTexture = new THREE.TextureLoader().load('textures/Flame03.png');
			fireAnim = new TextureAnimator(runnerTexture, 16, 4, 64, 60); // texture, #horiz, #vert, #total, duration.
			var runnerMaterial = new THREE.MeshBasicMaterial({ map: runnerTexture, side: THREE.DoubleSide, transparent: true });
			var runnerGeometry = new THREE.PlaneGeometry(30, 30, 1, 1);
			var runner = new THREE.Mesh(runnerGeometry, runnerMaterial);
			var runner1 = new THREE.Mesh(runnerGeometry, runnerMaterial);
			var runner2 = new THREE.Mesh(runnerGeometry, runnerMaterial);
			var runner3 = new THREE.Mesh(runnerGeometry, runnerMaterial);
			var runner4 = new THREE.Mesh(runnerGeometry, runnerMaterial);
			runner.position.set(0, 10, -40);
			runner.rotation.y = getRadian(-45);
			runner1.position.set(-30, 10, -40);
			runner2.position.set(-60, 10, 30);
			runner2.rotation.y = getRadian(90);
			runner3.position.set(60, 10, 20);
			runner3.scale.set(3, 3, 3);
			runner3.rotation.y = getRadian(90);
			runner4.position.set(20, 10, 70);
			scene1.add(runner);
			scene1.add(runner1);
			scene1.add(runner2);
			scene1.add(runner3);
			scene1.add(runner4);

			var ufoSuck = new THREE.Mesh(runnerGeometry, runnerMaterial);
			ufoSuck.position.set(0, 10, -80);
			ufoSuck.scale.set(100, 100, 100);
			ufoSuck.visible = false;
			ufoSuck.name = 'ufoSuck';
			scene1.add(ufoSuck);

			loadScene1();



			const debrisMgr = new ResourceTracker();
			const trackDebris = debrisMgr.track.bind(debrisMgr);
			var Debrisloader = new GLTFLoader(manager);
			Debrisloader.load("models/DebrisSoloN5.glb", function (gltf) {
				var Debris = trackDebris(gltf.scene);

				Debris.scale.set(20, 20, 20);

				Debris.position.set(-10, 0, 40);
				Debris.rotation.y = getRadian(-90);

				Debris.visible = true;

				var geometry;
				var material;

				Debris.traverse(function (o) {
					if (o.isMesh) {
						//console.log(o.name);
						geometry = o.geometry;
						material = o.material;
					}
				});




				makeInstanced(geometry, material);

				//scene1.add(Debris);
				//loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('door ' + (xhr.loaded) + ' loaded');
					var prc = Math.floor(xhr.loaded / 32162816 * 100);

				}
			);
			//material that the geometry will use 
			debrisMgr.dispose();

			var doorloader = new GLTFLoader(manager);
			doorloader.load("models/DoorRetopo4.glb", function (gltf) {
				var door = gltf.scene;

				door.scale.set(5, 5, 5);

				door.position.set(-50, 0, -6);
				door.rotation.y = getRadian(-45);

				door.visible = true;



				door.traverse(function (o) {
					if (o.isMesh) {
						console.log("door");
						//o.castShadow = true;
						if (o.name == "Plane002") {
							//o.rotation.y = getRadian(90);
							o.scale.x = -0.001;
						} else if (o.name == "Invisible") {
							o.material = new THREE.MeshStandardMaterial({ color: 0x000000 });
						}

					}
				});
				scene1.add(door);
				//loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('door ' + (xhr.loaded) + '% loaded');
					var prc = Math.floor(xhr.loaded / 3027156 * 100);

				}
			);
			// this centers the glow at the mesh


			var ufoloader = new GLTFLoader(manager);
			ufoloader.load("models/UFO.glb", function (gltf) {
				var ufo = gltf.scene;

				ufo.scale.set(40, 40, 40);

				ufo.position.set(-60, 60, -190);
				ufo.rotation.y = getRadian(-80);
				ufo.rotation.x = getRadian(5);


				ufo.visible = true;



				ufo.traverse(function (o) {
					if (o.isMesh) {
						console.log("UFO");
						if (o.name == 'Light') {
							o.material = new THREE.MeshBasicMaterial({ color: 0xC440FF, opacity: 0.6, transparent: true, });
						}
					}
				});

				scene1.add(ufo);

				var spriteMap = new THREE.TextureLoader().load("textures/glow.png");
				var spriteMaterial = new THREE.SpriteMaterial(
					{
						map: spriteMap,
						color: 0xC440FF, transparent: true, blending: THREE.AdditiveBlending

					});
				var sprite = new THREE.Sprite(spriteMaterial);
				sprite.scale.set(2.5, 2.5, 1.0);
				sprite.position.set(0, 0.3, 0);
				ufo.add(sprite);
				var sprite2 = new THREE.Sprite(spriteMaterial);
				sprite2.scale.set(1.5, 1.5, 1.0);
				sprite2.position.set(0, -0.1, 0);
				ufo.add(sprite2);

				var pLight = new THREE.PointLight(0xC440FF, 8, 140);
				pLight.rotation.x = getRadian(90);
				pLight.position.set(-60, 50, -190);
				scene1.add(pLight);

			},
				// called while loading is progressing
				function (xhr) {

					//console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

				}
			);
		}

		function loadScene1() {
			resMgr = new ResourceTracker();
			var track = resMgr.track.bind(resMgr);
			var somaloader = new GLTFLoader(manager);
			somaloader.load("models/somaTieren_sebas.glb", function (gltf) {

				var soma = track(gltf.scene);

				soma.scale.set(0.3, 0.3, 0.3);

				//soma.position.set(- 160, 6, 80);
				soma.rotation.y = getRadian(-90);

				soma.visible = true;
				soma.position.set(0, 2, 20);



				soma.traverse(function (o) {
					if (o.isMesh) {
						console.log("soma");
					}
				});
				scene1.add(soma);
				//loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('soma ' + (xhr.loaded) + 'loaded');
					var prc = Math.floor(xhr.loaded / 1413088 * 100);

					//updateLoadBar(prc);
				}
			);

			bildsMgr = new ResourceTracker();
			const trackBilds = bildsMgr.track.bind(bildsMgr);
			var bildloader = new GLTFLoader(manager);
			bildloader.load("models/All Bilds retopoGLTF.glb", function (gltf) {
				var bild = trackBilds(gltf.scene);

				bild.scale.set(0.17, 0.17, 0.17);
				bild.position.set(0, 5, 0);


				bild.rotation.y = getRadian(-90);

				bild.visible = true;

				bild.traverse(function (o) {
					if (o.isMesh) {
						//console.log(o.name);
						var map = o.material.map;
						var huMat = new THREE.MeshPhongMaterial({ map: map, transparent: true, opacity: 1, side: THREE.DoubleSide });
						o.material = huMat;
						o.rotation.z = getRadian(-90);
						switch (o.name) {
							case "Bild_5_Retopo":
								o.position.set(-80, 5, 250);
								o.rotation.x = getRadian(45);
								break;
							case "Bild_2_Retopo":
								o.position.set(-120, 5, -60);
								o.rotation.x = getRadian(90);
								o.rotation.z = getRadian(-30);
								break;
							case "Bild1_Retopo":
								o.position.set(380, 30, -30);
								o.rotation.z = getRadian(90);
								break;
							case "Bild_3_Retopo":
								o.position.set(110, 3, 200);
								o.rotation.x = getRadian(-20);
								o.rotation.z = getRadian(0);
								break;
							case "Bild_4_retopo_Back":
								o.position.set(110, 6.2, -200);
								o.rotation.z = getRadian(-10);
								o.rotation.x = getRadian(10);
								break;
						}
					}
				});
				scene1.add(bild);
				loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('bild ' + (xhr.loaded) + '% loaded');
					var prc = Math.floor(xhr.loaded / 19777540 * 100);
					updateLoadBar(prc);
				}
			);
		}

		function initScene2() {

			scene2loaded = true;
			scene2.add(controls.getObject());

			var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 1);
			light.position.set(0.5, 1, 0.75);
			scene2.add(light);

			var light1 = new THREE.PointLight(0xFFFFFF, 10, 140);
			light1.position.set(80, 10, -60);
			//scene2.add( light1 );

			var amblight = new THREE.AmbientLight(0xFFFFFF, 0.3);
			scene2.add(amblight);

			var texture = new THREE.TextureLoader().load("textures/Aurora3.png");
			var material = new THREE.MeshPhongMaterial({ color: 0x02FD01, alphaMap: texture, transparent: true, opacity: 1 });
			material.map = texture;
			material.color = new THREE.Color(0x02FD01);
			material.side = THREE.FrontSide;
			tsph = new THREE.Mesh(new THREE.SphereGeometry(34, 60, 40), material);
			tsph.position.set(-63, -45, -215);
			tsph.name = "Moon";
			scene2.add(tsph);


			var starGeo = new THREE.Geometry();
			for (let i = 0; i < 6000; i++) {
				let star = new THREE.Vector3(
					Math.random() * 300 - 200,
					Math.random() * 600 - 300,
					Math.random() * 600 - 400
				);
				starGeo.vertices.push(star);
			}
			let sprite = new THREE.TextureLoader().load('textures/glow.png');
			let starMaterial = new THREE.PointsMaterial({
				color: 0xaaaaaa,
				size: 0.5,
				map: sprite,
				transparent: true
			});
			var stars = new THREE.Points(starGeo, starMaterial);
			scene2.add(stars);

			loadScene2();
			//scene2.add(ufo);
			

			var ufoloader = new GLTFLoader(manager);
			ufoloader.load("models/UFOwithout.glb", function (gltf) {
				var ufo = gltf.scene;

				ufo.scale.set(30, 30, 30);

				ufo.position.set(-50, 60, -250);
				ufo.rotation.y = getRadian(-80);
				ufo.rotation.x = getRadian(10);

				ufo.visible = true;

				ufo.traverse(function (o) {
					if (o.isMesh) {
						console.log("UFO");
						if (o.name == "Light") o.material = new THREE.MeshBasicMaterial({ color: 0xC440FF, opacity: 0.2, transparent: true, });
					}
				});
				scene2.add(ufo);
				/*
								var spriteMap = new THREE.TextureLoader().load("textures/glow.png");
								var spriteMaterial = new THREE.SpriteMaterial(
									{
										map: spriteMap, useScreenCoordinates: false,
										color: 0xC440FF, transparent: true, blending: THREE.AdditiveBlending
				
									});
								var sprite = new THREE.Sprite(spriteMaterial);
								sprite.scale.set(2.2, 2.2, 1.0);
								sprite.position.set(0, 0.2, 0);
								ufo.add(sprite);
				*/
				var light = new THREE.PointLight(0xFFFFFF, 100, 60);
				light.position.set(-80, 60, -160)
				scene2.add(light);
				var light2 = new THREE.PointLight(0xFFFFFF, 60, 60);
				light2.position.set(30, 60, -210)
				scene2.add(light2);

				console.log('ufo added to scene');
				$("#loadText").html('loaded<br>');

				//loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('ufo ' + (xhr.loaded) + ' loaded');
					var prc = Math.floor(xhr.loaded / 2561968 * 100);

				}
			);

			/*
			var material = new THREE.MeshBasicMaterial();
			material.map = new THREE.TextureLoader().load("textures/Nebula.png");
			material.color = new THREE.Color(0xFFFFFF);
			material.side = THREE.BackSide;
			var sky = new THREE.Mesh(new THREE.SphereGeometry(500, 60, 40), material);
			sky.rotation.y = getRadian(0);
			//scene2.add(sky);
			*/

		}
		function loadScene2(){
			rocksMgr = new ResourceTracker();
			const trackRocks = rocksMgr.track.bind(rocksMgr);
			var rocksloader = new GLTFLoader(manager);
			rocksloader.load("models/SpaceWithoutBG.glb", function (gltf) {
				rocks = trackRocks(gltf.scene);

				//rocks.scale.set(0.05,0.05,0.05);

				rocks.position.set(0, 10, -250);
				rocks.rotation.y = getRadian(-80);
				rocks.rotation.x = getRadian(10);

				rocks.visible = true;

				rocks.traverse(function (o) {
					if (o.isMesh) {
						//console.log("rocks " + o.name);
						if (o.name == 'FirePlanet') {
							o.scale.set(50, 50, 50);
							o.position.set(80, -30, -50);
							o.material.roughness = 0.9;
							o.material.emissiveMap = o.material.map;

						} else if (o.name == 'Sphere') {
							o.scale.set(600, 600, 600);
						} else if (o.name == "Moon") {
							o.scale.set(30, 30, 30);
							o.position.set(30, -50, 70);
						}
						else if (o.name.includes("Beton")) {

							rocksGeo.push(o.geometry);
							rocksMats.push(o.material);

							switch (o.name) {
								case 'Beton_1':
									o.position.set(160, 15, 110);
									break;
								case 'Beton_2':
									o.position.set(180, 0, -70);
									break;
								case 'Beton_3':
									o.position.set(160, -40, 40);
									break;
								case 'Beton_4':
									o.position.set(-100, 0, 100);
									break;
								case 'Beton_5':
									o.position.set(110, 50, -80);
									break;
							}

							o.scale.set(0.5, 0.5, 0.5);
						}
					}
				});

				//setTimeout(function () { rocksMgr.dispose() }, 8000);
				var spriteMap = new THREE.TextureLoader().load("textures/glow.png");
				
				var spriteMaterial = new THREE.SpriteMaterial(
					{
						map: spriteMap,
						color: 0xd31313, transparent: true, blending: THREE.AdditiveBlending

					});
				var sprite = new THREE.Sprite(spriteMaterial);
				sprite.scale.set(128, 128, 1.0);
				sprite.position.set(80, -30, -50);
				rocks.add(sprite);

				var spriteMaterial2 = new THREE.SpriteMaterial(
					{
						map: spriteMap,
						color: 0x1eff00, transparent: true, blending: THREE.AdditiveBlending

					});
				var sprite2 = new THREE.Sprite(spriteMaterial2);
				sprite2.scale.set(80, 80, 1.0);
				sprite2.position.set(30, -50, 70);
				rocks.add(sprite2);


				scene2.add(rocks);
				console.log('rocks added to scene');
				//rocksGeo.forEach(makeInstancedRocks);


				loaded();
				//rocks.traverse(function (o) {if(o.isMesh)mesh.dispose();});
			},
				// called while loading is progressing
				function (xhr) {
					console.log('rocks ' + (xhr.loaded) + ' loaded');
					var prc = Math.floor(xhr.loaded / 7119612 * 100);

					updateLoadBar(prc);
				}
			);
		}

		function initScene3() {

			scene3loaded = true;
			scene3.add(controls.getObject());



			var amblight = new THREE.AmbientLight(0x02FD01, 0.2); // soft white light
			scene3.add(amblight);

			var light2 = new THREE.PointLight(0xFFFFFF, 3.5, 2000);
			light2.position.set(0.5, 15, 4);
			//light2.castShadow = true;
			scene3.add(light2);

			loadScene3();

			var doorloader = new GLTFLoader(manager);
			doorloader.load("models/DoorRetopo4.glb", function (gltf) {
				var door = gltf.scene;
				var plane2;
				door.scale.set(5, 5, 5);

				door.position.set(-30, 0, 0);
				door.rotation.y = getRadian(-45);

				door.visible = true;



				door.traverse(function (o) {
					if (o.isMesh) {
						console.log("door");
						//o.castShadow = true;
						if (o.name == "Plane002") {
							//o.rotation.y = getRadian(90);
							//o.rotation.x = getRadian(90);
							plane2 = o;
						} else if (o.name == "Invisible") {
							o.material = new THREE.MeshStandardMaterial({ color: 0x000000 });
						}

					}
				});
				scene3.add(door);

			},
				// called while loading is progressing
				function (xhr) {
					console.log('door ' + (xhr.loaded) + '% loaded');
					var prc = Math.floor(xhr.loaded / 3027156 * 100);

				}
			);

			var geometry = new THREE.BoxGeometry(6, 15, 6);
			//var geo2 = new THREE.BoxGeometry(5, 15, 5);
			var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
			var cube = new THREE.Mesh(geometry, material);
			var cube2 = new THREE.Mesh(geometry, material);
			var cube3 = new THREE.Mesh(geometry, material);
			cube.position.set(15, 8, 10);
			cube2.position.set(-5, 8, -15);
			cube3.position.set(-20, 7, 30);
			cube.visible = false;
			cube2.visible = false;
			cube3.visible = false;
			scene3.add(cube);
			scene3.add(cube2);
			scene3.add(cube3);


			var texture = new THREE.TextureLoader().load("textures/Aurora3.png");
			//var material = new THREE.MeshPhongMaterial({ color: 0x000000, alphaMap: texture, transparent: true, opacity: 0.6 });
			var material2 = new THREE.MeshBasicMaterial();
			material2.map = texture;
			//material.map = texture;
			material2.side = THREE.BackSide;
			//material.color = new THREE.Color(0xFFFFFF);
			//material.side = THREE.BackSide;
			gasSphere = new THREE.Mesh(new THREE.SphereGeometry(70, 30, 20), material2);
			//var tsph = new THREE.Mesh(new THREE.SphereGeometry(90, 60, 40), material2);
			scene3.add(gasSphere);
			//scene3.add(tsph);
		}
		function loadScene3() {
			moonMgr = new ResourceTracker();
			var trackMoon = moonMgr.track.bind(moonMgr);
			var moonloader = new GLTFLoader(manager);
			moonloader.load("models/moon9.glb", function (gltf) {
				var moon = trackMoon(gltf.scene);

				moon.scale.set(0.8, 0.8, 0.8);

				//moon.position.set(- 160, 6, 80);
				moon.rotation.y = getRadian(-90);

				moon.visible = true;



				moon.traverse(function (o) {
					if (o.isMesh) {
						console.log("moon");
						//o.receiveShadow = true;
						//createDecal();

					}
				});
				scene3.add(moon);

				//loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('moon ' + (xhr.loaded) + '% loaded');
					var prc = Math.floor(xhr.loaded / 3027156 * 100);

					updateLoadBar(prc);
				}
			);
			stat3Mgr = new ResourceTracker();
			var trackStat3 = stat3Mgr.track.bind(stat3Mgr);
			var Statueloader = new GLTFLoader(manager);
			Statueloader.load("models/StatuesAnim3.glb", function (gltf) {
				var Statue = trackStat3(gltf.scene);

				Statue.scale.set(8, 8, 8);

				Statue.position.set(15, 0, 10);
				Statue.rotation.y = getRadian(240);


				Statue.visible = true;

				Statue.traverse(function (o) {

					if (o.isMesh) {
						//console.log(o.name);
						//o.castShadow = true;
						//o.rotation.y = getRadian(90);
						//o.rotation.x = getRadian(90);


					}
				});

				mixer = new THREE.AnimationMixer(gltf.scene);
				mixer.clipAction(gltf.animations[0]).play();
				mixer.timeScale = 1.6;

				scene3.add(Statue);

			},
				// called while loading is progressing
				function (xhr) {
					console.log('Statue ' + (xhr.loaded) + 'B loaded');
					var prc = Math.floor(xhr.loaded / 10260068 * 100);

				}
			);
			stat2Mgr = new ResourceTracker();
			var trackStat2 = stat2Mgr.track.bind(stat2Mgr);
			var Statue2loader = new GLTFLoader(manager);
			Statue2loader.load("models/StatuesAnim2.glb", function (gltf) {
				var Statue2 = trackStat2(gltf.scene);

				Statue2.scale.set(8, 8, 8);

				Statue2.position.set(-5, -0.4, -15);
				Statue2.rotation.y = getRadian(180);

				Statue2.visible = true;

				Statue2.traverse(function (o) {
					if (o.isMesh) {
						//console.log(o.name);
						//o.castShadow = true;
						//o.rotation.y = getRadian(90);
						//o.rotation.x = getRadian(90);
					}
				});

				mixer2 = new THREE.AnimationMixer(gltf.scene);
				mixer2.clipAction(gltf.animations[0]).play();
				mixer2.timeScale = 1.3;

				scene3.add(Statue2);

			},
				// called while loading is progressing
				function (xhr) {
					console.log('Statue2 ' + (xhr.loaded) + 'B loaded');
					var prc = Math.floor(xhr.loaded / 10260068 * 100);

				}
			);

			stat1Mgr = new ResourceTracker();
			var trackStat1 = stat3Mgr.track.bind(stat1Mgr);
			var Statue3loader = new GLTFLoader(manager);
			Statue3loader.load("models/StatuesAnim1.glb", function (gltf) {
				var Statue3 = trackStat1(gltf.scene);

				Statue3.scale.set(8, 8, 8);

				Statue3.position.set(-20, -1.2, 24);
				Statue3.rotation.y = getRadian(-20);

				Statue3.visible = true;

				Statue3.traverse(function (o) {
					if (o.isMesh) {
						//console.log(o.name);
						//o.castShadow = true;
						//o.rotation.y = getRadian(90);
						//o.rotation.x = getRadian(90);
					}
				});

				mixer3 = new THREE.AnimationMixer(gltf.scene);
				mixer3.clipAction(gltf.animations[0]).play();
				mixer3.timeScale = 1.3;

				scene3.add(Statue3);
				loaded();
			},
				// called while loading is progressing
				function (xhr) {
					console.log('Statue3 ' + (xhr.loaded) + 'B loaded');
					var prc = Math.floor(xhr.loaded / 10260068 * 100);

				}
			);
		}

		function init() {
			//clock = new THREE.Clock();
			camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1500);
			camera.position.y = 10;
			camera.position.z = 30;
			scene = new THREE.Scene();

			scene1 = new THREE.Scene();
			scene2 = new THREE.Scene();
			scene3 = new THREE.Scene();

			currentScene = scene2;
			scene.background = new THREE.Color(0x000000);
			scene3.background = new THREE.Color(0x02FD01);
			//scene.fog = new THREE.Fog( 0xffffff, 0, 750 );
			scene1.fog = new THREE.Fog(0x000000, 0, 400);
			scene2.fog = new THREE.Fog(0x000000, 0, 900);
			scene3.fog = new THREE.Fog(0x02FD01, 0, 200);

			var light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 2);
			light.position.set(0.5, 3, 0.75);
			scene.add(light);



			controls = new PointerLockControls(camera, document.body);

			var blocker = document.getElementById('blocker');
			var instructions = document.getElementById('instructions');

			var up = document.getElementById('up');
			var down = document.getElementById('down');
			var left = document.getElementById('left');
			var right = document.getElementById('right');

			crossHair = document.getElementById('crossHair');
			/*
			var footer = document.getElementById( 'footer' );
			
			footer.addEventListener( 'click', switchScenes, false );
*/

			//party
			var particleMat = new THREE.SpriteMaterial({ map: new THREE.TextureLoader().load('textures/Pill.png'), color: 0xffffff });

			for (var i = 0; i < 60; i++) {

				particle = new Particle3D(particleMat.clone());
				particle.position.x = Math.random() * -60 - 30;
				particle.position.y = Math.random() * 80 - 30;
				particle.position.z = Math.random() * -190 - 80;
				particle.scale.x = 6;
				particle.scale.y = 6;

				scene1.add(particle);

				particles.push(particle);
			}
			var particleSMat = new THREE.SpriteMaterial({ map: new THREE.TextureLoader().load('textures/SomaIcov1.png'), color: 0xffffff });
			for (var i = 0; i < 60; i++) {

				particleS = new Particle3D(particleSMat.clone());
				particle.position.x = Math.random() * -60 - 30;
				particle.position.y = Math.random() * 90 - 30;
				particle.position.z = Math.random() * -190 - 80;
				particleS.scale.x = 10;
				particleS.scale.y = particleS.scale.x;

				scene1.add(particleS);

				particlesS.push(particleS);
			}

			up.addEventListener('touchstart', function (e) {
				canClick = false;
				moveForward = true;
				moveBackward = false;
				moveLeft = false;
				moveRight = false;
			}, false);
			up.addEventListener('touchend', function (e) {
				canClick = true;
				moveForward = false;

			}, false);
			down.addEventListener('touchstart', function (e) {
				canClick = false;
				moveForward = false;
				moveBackward = true;
				moveLeft = false;
				moveRight = false;
			}, false);
			down.addEventListener('touchend', function (e) {
				canClick = true;
				moveBackward = false;

			}, false);
			left.addEventListener('touchstart', function (e) {
				canClick = false;
				moveForward = false;
				moveBackward = false;
				moveLeft = true;
				moveRight = false;
			}, false);
			left.addEventListener('touchend', function (e) {
				canClick = true;
				moveLeft = false;

			}, false);
			right.addEventListener('touchstart', function (e) {
				canClick = false;
				moveForward = false;
				moveBackward = false;
				moveLeft = false;
				moveRight = true;
			}, false);
			right.addEventListener('touchend', function (e) {
				canClick = true;
				moveRight = false;

			}, false);

			//var simple = document.getElementById('down');
			document.getElementById('simple').addEventListener('mousedown', function (e) {
				window.location.href = "http://exhibition.nessi-nezilla.de/360.html";
			});
			document.getElementById('simple').addEventListener('touchstart', function (e) {
				window.location.href = "http://exhibition.nessi-nezilla.de/360.html";
			});


			footer.addEventListener('touchstart', function (e) {
				e.returnValue = false;
				e.preventDefault();
console.log('dddddd');
				var txt = $(e.target).text();


				console.log(txt);
				fadeInstr();
				

				setTimeout(function () { goToScene(txt) }, 1000);

				transition = true;
				controls.unlock();
				//controls.unlock();					
			});


			/*
			
						instructions.addEventListener('click', function () {
			
							if (currentSceneLoaded == true & transition == true) {
								controls.lock();
								if (tutorial == true) {
									playSound("Space");
									tutorial = false;
									$("#clickToEnter").html('');
								}
								transition = false;
							}
			
						}, false);*/
			//body
			var shortClick = false;
			var mousex, mousey;
			document.addEventListener('touchstart', function (e) {
				e.preventDefault();
				//e.returnValue = false;
				console.log("touchStart");
				//onDocumentMouseDown(e);
				shortClick = true;
				setTimeout(function(e){
					shortClick = false;
				},300);
				mousex = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
				mousey =  - (event.touches[0].clientY / window.innerHeight) * 2 + 1;
			}, false);

			document.addEventListener('touchend', function (e) {
				e.preventDefault();
				//e.returnValue = false;
				console.log("touchStart");
				if(shortClick == true) onDocumentMouseDown(e, mousex,mousey);
				shortClick = false;
			}, false);



			if (isMobile == false) {
				document.addEventListener('mousemove', onDocumentMouseMove, false);
				document.addEventListener('mousedown', onDocumentMouseDown, false);
			} else {
				document.addEventListener('touchmove', onDocumentMouseMove, false);
			}



			controls.addEventListener('lock', function () {

				transition = false;
			});

			controls.addEventListener('unlock', function () {
				//fadeInstr();
				//blocker.style.display = 'block';
				//instructions.style.display = '';

				transition = true;

			});


			document.addEventListener('visibilitychange', function () {
				//document.title = document.visibilityState;
				console.log(document.visibilityState);
				if (document.hidden) {
					//sound.pause();
					var audio = document.getElementById('music');
					audio.pause();
				}
				else {
					var audio = document.getElementById('music');
					audio.play();
				}
			});



			var onKeyDown = function (event) {
				if (transition == false) {
					switch (event.keyCode) {


						case 38: // up
						case 87: // w
							moveForward = true;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true;
							break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							break;

						case 32: // space
							if (canJump === true) velocity.y += 250;
							canJump = false;
							break;

					}
				}
				else {


					moveForward = false;
					moveLeft = false;
					moveBackward = false;
					moveRight = false;
				}

			};

			var onKeyUp = function (event) {

				switch (event.keyCode) {

					case 38: // up
					case 87: // w
						moveForward = false;
						break;

					case 37: // left
					case 65: // a
						moveLeft = false;
						break;

					case 40: // down
					case 83: // s
						moveBackward = false;
						break;

					case 39: // right
					case 68: // d
						moveRight = false;
						break;

				}

			};

			document.addEventListener('keydown', onKeyDown, false);
			document.addEventListener('keyup', onKeyUp, false);

			raycaster = new THREE.Raycaster();
			mouse = new THREE.Vector2();

			raycaster2 = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, - 1, 0), 0, 10);

			//initPaintings();
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			//renderer.toneMapping = THREE.ReinhardToneMapping;
			//renderer.toneMappingExposure = 2.3;

			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.BasicShadowMap;
			//renderer.gammaOutput = true;
			//renderer.gammaFactor = 2.2;

			document.body.appendChild(renderer.domElement);


			window.addEventListener('resize', onWindowResize, false);

			setTimeout(function (e) {
				initScene2();
				scene2.add(controls.getObject());
			}, 100);

		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		var randomizeMatrix = function () {

			var position = new THREE.Vector3();
			var rotation = new THREE.Euler();
			var quaternion = new THREE.Quaternion();
			var scale = new THREE.Vector3();

			return function (matrix) {

				position.x = 0;
				position.y = Math.random() * 260 - 130;
				position.z = Math.random() * 260 - 130;

				//rotation.x = getRadian(90);
				rotation.x = Math.random() * 2 * Math.PI;
				rotation.z = getRadian(-90);
				//rotation.y = getRadian(90);
				if (isAppleDevice == false) {
					//rotation.y = getRadian(0);
					//console.log(rotation);
				} /*else if (isAppleDevice) {
					rotation.x = 0;
					rotation.y = 0;
					rotation.z = 1.57;
					//console.log(rotation);
				}*/
				if (isChrome == false) {
					//rotation.x = getRadian(-90);
					//rotation.y = getRadian(90);
					//rotation.z = getRadian(90);
					//console.log(rotation);
				}


				quaternion.setFromEuler(rotation);
				var max = 0.5;
				var min = 0.3;
				scale.x = scale.y = scale.z = Math.random() * (max - min) + min;


				matrix.compose(position, quaternion, scale);

			};

		}();


		var randomizeMatrixRocks = function () {

			var position = new THREE.Vector3();
			var rotation = new THREE.Euler();
			var quaternion = new THREE.Quaternion();
			var scale = new THREE.Vector3();

			return function (matrix) {

				position.x = Math.random() * 260 - 130;
				position.y = Math.random() * 260 - 130;
				position.z = 0;

				//rotation.x = Math.random() * 2 * Math.PI;
				//rotation.y = Math.random() * 2 * Math.PI;
				rotation.z = Math.random() * 2 * Math.PI;

				rotation.y = getRadian(90);


				quaternion.setFromEuler(rotation);
				var max = 0.5;
				var min = 0.1;
				scale.x = scale.y = scale.z = 0.01;

				matrix.compose(position, quaternion, scale);

			};

		}();

		function createDecal() {

			var huTex = new THREE.TextureLoader().load("textures/Gas.jpg");
			var geometry = new THREE.PlaneGeometry(2, 3, 3);
			var material = new THREE.MeshPhongMaterial({ map: huTex, side: THREE.DoubleSide });
			var plane = new THREE.Mesh(geometry, material);
			plane.position.set(0, 0.3, 0);
			plane.rotation.x = getRadian(-90);
			plane.scale.set(-2, -2, 2);
			scene3.add(plane);

			var huTex2 = new THREE.TextureLoader().load("textures/Gas_.jpg");
			var material2 = new THREE.MeshPhongMaterial({ map: huTex2, side: THREE.DoubleSide, specular: 0, roughness: 1 });
			var plane2 = new THREE.Mesh(geometry, material2);
			plane2.position.set(-10, 0.3, 8);
			plane2.rotation.x = getRadian(90);
			plane2.rotation.z = getRadian(90);
			plane2.scale.set(-2, -2, 2);
			scene3.add(plane2);





		}

		function createDecalFire(mesh) {

			var huTex = new THREE.TextureLoader().load("textures/Feuer.jpg");
			var geometry = new THREE.PlaneGeometry(20, 30, 32);
			var material = new THREE.MeshPhongMaterial({ color: 0xffffff, alphaMap: huTex, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
			var plane = new THREE.Mesh(geometry, material);
			plane.position.set(30, 30, -35);

			plane.scale.set(2, 2, 2);
			scene1.add(plane);

			var huTex2 = new THREE.TextureLoader().load("textures/Feuer_.jpg");
			var geometry2 = new THREE.PlaneGeometry(20, 30, 32);
			var material2 = new THREE.MeshPhongMaterial({ color: 0xffffff, alphaMap: huTex2, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
			var plane2 = new THREE.Mesh(geometry, material2);
			plane2.position.set(20, 30, 95);
			plane2.scale.set(2, 2, 2);
			scene1.add(plane2);

		}


		function makeInstanced(geometry, material) {

			var count = 180;
			var matrix = new THREE.Matrix4();
			var mesh = new THREE.InstancedMesh(geometry, material, count);

			for (var i = 0; i < count; i++) {

				randomizeMatrix(matrix);
				mesh.setMatrixAt(i, matrix);

			}
			mesh.rotation.z = getRadian(90);
			mesh.position.set(0, -1, 0);
			scene1.add(mesh);
		}


		function makeInstancedRock(geometry, material, i) {
			var count = 1;
			var matrix = new THREE.Matrix4();
			var mesh = new THREE.InstancedMesh(geometry, material, count);

			var position = new THREE.Vector3();
			var rotation = new THREE.Euler();

			var quaternion = new THREE.Quaternion();
			var scale = new THREE.Vector3();

			switch (i) {
				case 0:

					position.x = -20;
					position.y = 0;
					position.z = 15;

					rotation.x = 90;
					rotation.y = 0;
					rotation.z = 0;

					break;
				case 1:
					position.x = -15;
					position.y = 1;
					position.z = -10;

					rotation.x = 0;
					rotation.y = 0;
					rotation.z = 10;
					break;
				case 2:
					position.x = 15;
					position.y = 0;
					position.z = 20;

					rotation.x = 0;
					rotation.y = 0;
					rotation.z = 90;
					break;
				case 3:
					position.x = 0;
					position.y = 0;
					position.z = -20;

					rotation.x = 0;
					rotation.y = 0;
					rotation.z = 0;
					break;
				case 4:
					position.x = -15;
					position.y = 0;
					position.z = 20;

					rotation.x = 0;
					rotation.y = 0;
					rotation.z = 30;
					break;
			}
			rotation.x = -80;

			quaternion.setFromEuler(rotation);
			var max = 0.05;
			var min = 0.01;
			scale.x = scale.y = scale.z = 0.1;


			matrix.compose(position, quaternion, scale);

			mesh.setMatrixAt(0, matrix);

			//mesh.scale.set(1,1,1);
			//mesh.rotation.x = getRadian(90);
			mesh.position.set(0, -0.2, 0);
			//mesh.castShadow = true;
			scene3.add(mesh);
			//scene1.add(mesh);

		}

		function makeInstancedRocks(item, i) {
			makeInstancedRock(rocksGeo[i], rocksMats[i], i);
			//rocksMats[i].dispose();
		}

		function rotateDoor(vectorToAnimate, target, options) {
			var speed = 3000;
			// create the tween
			var tween = new TWEEN.Tween(vectorToAnimate).to(target, speed)
				.easing(TWEEN.Easing.Quintic.Out)
				.onComplete(function () {
				});
			tween.onUpdate(function () {
				//console.log(vectorToAnimate);
				options.rotation.y = vectorToAnimate.y;
			});
			// start the tween
			tween.start();
		}

		function moveCamera(vectorToAnimate, target, options) {
			var speed = 4000;
			// create the tween
			var tween = new TWEEN.Tween(vectorToAnimate).to(target, speed)
				.easing(TWEEN.Easing.Quintic.Out)
				.onComplete(function () {
				});
			tween.onUpdate(function () {
				//console.log(vectorToAnimate);
				options.position.z = vectorToAnimate.z;
				options.position.x = vectorToAnimate.x;
			});
			// start the tween
			tween.start();
		}

		function tripCamera(vectorToAnimate, target, options, freeMov) {
			var speed = 4000;
			// create the tween
			var tween = new TWEEN.Tween(vectorToAnimate).to(target, speed)
				.easing(TWEEN.Easing.Quintic.Out)
				.onComplete(function () {
				});
			tween.onUpdate(function () {
				//console.log(vectorToAnimate);
				camera.fov = vectorToAnimate.x;
				camera.updateProjectionMatrix();
				if (false) {
					camera.position.z = 30;
					camera.position.x = 0;
				}
			});
			// start the tween
			tween.start();
		}


		var hoverNowName, hoverNowObj;

		function onDocumentMouseMove(event) {
			event.preventDefault();
			event.returnValue = false;
			//mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			//mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

			mouse.x = 0;
			mouse.y = 0;



			raycaster.setFromCamera(mouse, camera);
			var intersects = raycaster.intersectObjects(currentScene.children, true);

			if (intersects.length > 0) {

				var oName = intersects[0].object.name;
				//console.log("hover" + oName);
				if ((oName == "Fire" || oName == "ufoSuck") && intersects.length > 1) oName = intersects[1].object.name;
				if (oName.includes("P_") && oName != 'GagarinLP_1_-__0' && document.getElementById("size").className != "fade") {
					hoverNowName = oName;
					setSizetext(oName);
					fadeSize();
					console.log("hover" + oName);
				}
				if (oName == "FirePlanet" || oName == "Ship" || oName == "Emmisive" || oName == "Moon" || oName == "Plane002" || oName == "Invisible" || oName.includes("P_")) {
					if (!oName.includes("P_")) crossHair.style.display = 'block';
					if ((oName == "Plane002") && getEuler(intersects[0].object.rotation.y) == 0) {
						var vec = { x: 0, y: 0, z: 0 };
						rotateDoor(vec, { x: 0, y: getRadian(index == 1 ? -40 : -70), z: 0 }, intersects[0].object);

						hoverNowName = oName;
						hoverNowObj = intersects[0].object;
					}

				}
				else {
					crossHair.style.display = 'none';
					if (hoverNowName == "Plane002" || hoverNowName == "Invisible") {

						var vec = { x: 0, y: getRadian(index == 1 ? 60 : -70), z: 0 };
						//rotateDoor(vec, { x: 0, y: 0, z: 0 }, hoverNowObj);
					}
					if (hoverNowName != null) {
						if (hoverNowName.includes("P_")) {
							fadeSize();
						}
					}
					hoverNowName = null;
					hoverNowObj = null;
				}

				$('html,body').css('cursor', 'default');
			} else {
				crossHair.style.display = 'none';
				$('html,body').css('cursor', 'default');

			}


		}


		function onDocumentMouseDown(event, mousex, mousey) {
			var e = event;
			//if (e.stopPropagation) e.stopPropagation();
			if (e.preventDefault) e.preventDefault();
			e.cancelBubble = true;
			e.returnValue = false;
			console.log("mouseDown");

			if (currentSceneLoaded == true & transition == true & canClick == true & (blocker.className == "fade" || tutorial == true)) {
				controls.lock();
				fadeInstr();
				if (tutorial == true) {
					playSound("Space");
					tutorial = false;
					$("#clickToEnter").html('');
					footer.style.display = 'block';
					moveCamera({ x: 0, y: 0, z: 400 }, { x: 0, y: 0, z: 30 }, camera);
					//setTimeout(function () { renderer.dispose() }, 6000);
				}
				transition = false;
				return;
			}


			if (blocker.style.display == 'block') {
				//initTrans();
				return;
			}
			if (isMobile == false) {
				mouse.x = 0;
				mouse.y = 0;
			} else if(mousex == null && mousey == null){
				mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
				mouse.y = - (event.touches[0].clientY / window.innerHeight) * 2 + 1;
			} else {
				mouse.x = mousex;
				mouse.y = mousey
			}




			raycaster.setFromCamera(mouse, camera);
			var intersects = raycaster.intersectObjects(currentScene.children, true);
			var to;
			if (intersects[0] != null) {
				var o;
				o = intersects[0].object;
				console.log(o.name);
				if ((o.name == "Fire" || o.name == "ufoSuck") && intersects.length > 1) o = intersects[1].object;
				if (intersects.length > 0) {

				}
				if (intersects.length > 0) {
					if (transition == false && tutorial == false && canClick == true/* && blocker.style.display == 'none'*/) {
						clicker(o);
					//lightbox_open();
					//animateMove(camera.position,{x: to.position.x - 2, y: to.position.y,z: to.position.z + 0.5},to.position,1000);
					console.log("click");
					}
				}
			}
		}

		function fadeInstr(v) {
			instructions.classList.toggle('fade');
			blocker.classList.toggle('fade');
			if (v != null & false) {
				blocker.style.backgroundColor = v;
			}
		}

		function fadeSize() {
			var size = document.getElementById('size');
			size.classList.toggle('fade');
		}
		function setSizetext(oName) {
			switch (oName) {
				case 'P_3':
				case 'P_7':
				case 'P_4':
				case 'P_6':
					$("#size").html('300 X 170');
					break;
				default:
					$("#size").html('270 X 180');
					break;
			}

		}


		function clicker(o) {
			//console.log(o.name);


			velocity.z = 0;
			velocity.x = 0;
			$("#loadText").html('  LOADING<div id="clickToEnter" > </div>');
			switch (o.name) {
				case "FirePlanet":
					//goToScene("Fire");
					tripCamera({ x: 60, y: 0, z: 0 }, { x: 10, y: 0, z: 0 }, camera);
					fadeInstr('black');
					controls.unlock();
					setTimeout(function () {
						goToScene("Fire");
					}, 1000);

					canClick = false;
					setTimeout(function () { canClick = true; resetVelocity(); }, 2000);
					//blocker.style.display = 'block';
					//instructions.style.display = 'block';
					transition = true;
					break;
				case "Ship":
					tripCamera({ x: 60, y: 0, z: 0 }, { x: 10, y: 0, z: 0 }, camera);
					fadeInstr('pink');
					controls.unlock();
					setTimeout(function () { goToScene("UFO") }, 1000);
					//blocker.style.backgroundColor = rgba(1,1,1,1);
					//goToScene("UFO");



					canClick = false;
					setTimeout(function () { canClick = true; resetVelocity(); }, 2000);
					//blocker.style.display = 'block';
					//instructions.style.display = 'block';
					transition = true;
					break;
				case "Emmisive":
					tripCamera({ x: 60, y: 0, z: 0 }, { x: 10, y: 0, z: 0 }, camera);
					fadeInstr('pink');
					controls.unlock();
					setTimeout(function () { goToScene("UFO") }, 1000);


					canClick = false;
					setTimeout(function () { canClick = true; resetVelocity(); }, 2000);
					//blocker.style.display = 'block';
					//instructions.style.display = 'block';
					transition = true;
					break;
				case "Moon":
					tripCamera({ x: 60, y: 0, z: 0 }, { x: 10, y: 0, z: 0 }, camera);
					fadeInstr('green');
					controls.unlock();
					setTimeout(function () { goToScene("AtomGas") }, 1000);


					canClick = false;
					setTimeout(function () { canClick = true; resetVelocity(); }, 2000);
					//blocker.style.display = 'block';
					//instructions.style.display = 'block';
					transition = true;
					break;
				case 'Invisible':
				case "Plane002":
					tripCamera({ x: 60, y: 0, z: 0 }, { x: 10, y: 0, z: 0 }, camera);
					controls.unlock();
					fadeInstr("green");
					if (index == 1) {
						setTimeout(function () { goToScene("AtomGas") }, 1000);

					} else if (index == 3) {
						setTimeout(function () { goToScene("Fire") }, 1000);

					} else if (index == 0) {
						setTimeout(function () { goToScene("AtomGas") }, 1000);

					}
					canClick = false;
					setTimeout(function () { canClick = true; resetVelocity(); }, 2000);

					transition = true;
					break;
			}

		}

		function resetVelocity() {
			velocity.z = 0;
			velocity.x = 0;
		}

		function dispose(sc) {


			scene2.traverse(function (o) {
				if (o.isMesh) {
					//o.dispose();
					//createDecal();
				}
				if (o.geometry) {
					o.geometry.dispose()
					console.log("dispose geometry ", o.geometry)
				}

				if (o.material) {
					if (o.material.length) {
						for (let i = 0; i < o.material.length; ++i) {
							o.material[i].dispose()
							console.log("dispose material ", o.material[i])
						}
					}
					else {
						o.material.dispose()
						console.log("dispose material ", o.material)
					}
				}


			});
			currentScene.traverse(function (o) {
				if (o.isMesh) {
					//o.dispose();
					//createDecal();
				}
				if (o.geometry) {
					o.geometry.dispose();
					//console.log("dispose geometry ", o.geometry);

				}

				if (o.material) {
					if (o.material.length) {
						for (let i = 0; i < o.material.length; ++i) {
							o.material[i].dispose();
							//console.log("dispose material ", o.material[i]);
						}
					}
					else {
						o.material.dispose();
						//console.log("dispose material ", o.material);
					}
				}


			});
			//currentScene = scene1;
			//scene2 = null;

		}

		var t = 0;

		function animate() {

			requestAnimationFrame(animate);
			TWEEN.update();
			///party
			if (index == 1) {
				for (var i = 0; i < particles.length; i++) {

					var particle = particles[i];
					particle.updatePhysics();
					var p = particle.position;
					particle.material.rotation += randomRange(-0.1, 0.1);
					if (p.y < -20) {
						particle.position.y = 60;
						particle.position.x = -60;
						particle.position.z = -190;
					}
					if (p.x > 500) particle.position.x -= 500;
					else if (p.x < -500) particle.position.x += 500;
					if (p.z > 500) particle.position.z -= 500;
					else if (p.z < -500) particle.position.z += 500;


				}
				for (var i = 0; i < particlesS.length; i++) {

					var particle = particlesS[i];
					particle.updatePhysics();
					var p = particle.position;
					particle.material.rotation += randomRange(-0.1, 0.1);
					if (p.y < -20) {
						particle.position.y = 60;
						particle.position.x = -60;
						particle.position.z = -190;
					}
					if (p.x > 500) particle.position.x -= 500;
					else if (p.x < -500) particle.position.x += 500;
					if (p.z > 500) particle.position.z -= 500;
					else if (p.z < -500) particle.position.z += 500;


				}
			}

			if (rocks != null && index == 2) rocks.traverse(function (o) {
				if (o.isMesh & o.name.includes("Beton")) {

					switch (o.name) {
						case 'Beton_1':
							o.rotation.x -= 0.0009;
							o.rotation.z += 0.0008;
							break;
						case 'Beton_2':
							o.rotation.y += 0.0002;
							o.rotation.z -= 0.00014;
							break;
						case 'Beton_3':
							o.rotation.x += 0.0009;
							o.rotation.y += 0.00015;
							break;
						case 'Beton_4':
							o.rotation.x += 0.0009;
							o.rotation.z -= 0.0008;
							break;
						case 'Beton_5':
							o.rotation.x -= 0.00011;
							o.rotation.y -= 0.0008;
							break;
					}
				}
			});
			if (gasSphere != null && index == 3) {
				//gasSphere.rotation.x -= 0.0008;
				gasSphere.rotation.y -= 0.001;
			}
			if (tsph != null && index == 2) {
				//tsph.rotation.x -= 0.0008;
				//tsph.rotation.y -= 0.00002;
			}

			if (controls.isLocked != true) {
				resetVelocity();
			}
			//console.log(velocity);
			if (controls.isLocked === true) {

				//raycaster.ray.origin.copy(controls.getObject().position);
				//raycaster.ray.origin.y -= 10;

				//var intersections = raycaster.intersectObjects(objects);

				var onObject = false; //intersections.length > 0;

				var time = performance.now();
				var delta = (time - prevTime) / 1000;

				if (index == 3) {
					if (mixer) mixer.update(delta);
					if (mixer2) mixer2.update(delta);
					if (mixer3) mixer3.update(delta);
				}

				velocity.x -= velocity.x * 10.0 * delta;
				velocity.z -= velocity.z * 10.0 * delta;

				velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

				direction.z = Number(moveForward) - Number(moveBackward);
				direction.x = Number(moveRight) - Number(moveLeft);
				direction.normalize(); // this ensures consistent movements in all directions

				if (moveForward || moveBackward) velocity.z -= direction.z * 200.0 * delta;
				if (moveLeft || moveRight) velocity.x -= direction.x * 200.0 * delta;

				//console.log(velocity);

				if (index == 1) {
					fireAnim.update(1000 * delta);
				}

				raycaster2.setFromCamera(mouse, camera);

				//raycaster2.ray.origin.copy(controls.getObject().position);
				//raycaster2.ray.origin.x -= 10;

				var intersects2 = raycaster2.intersectObjects(currentScene.children, true);
				if (intersects2.length > 0 & velocity.z < 0) {
					if (intersects2[0].object.name != "Fire" & intersects2[0].object.name != 'Aset_cement_rubble_S_riuvL_LOD4') {
						console.log("MoveForwardBLock ");
						velocity.z = 0;
						velocity.x = 0;
						//return;

						if (intersects2[0].object.name == "ufoSuck") {
							transition = true;
							canClick = false;
							setTimeout(function () { canClick = true; resetVelocity(); }, 2000);
							controls.unlock();
							fadeInstr("green");
							setTimeout(function () { goToScene("UFO") }, 1000);
						}
						if (intersects2[0].object.name == "Invisible") {
							fadeInstr("green");
							if (index == 1) {
								setTimeout(function () { goToScene("AtomGas") }, 1000);

							} else if (index == 3) {
								setTimeout(function () { goToScene("Fire") }, 1000);

							} else if (index == 0) {
								setTimeout(function () { goToScene("AtomGas") }, 1000);

							}
							canClick = false;
							setTimeout(function () { canClick = true; resetVelocity(); }, 2000);

							controls.unlock();
							transition = true;
						}
					}
				}

				controls.moveRight(- velocity.x * delta);
				controls.moveForward(- velocity.z * delta);


				controls.getObject().position.y += (velocity.y * delta); // new behavior

				if (controls.getObject().position.y < 10) {

					velocity.y = 0;
					controls.getObject().position.y = 10;

					canJump = false;

				}

				prevTime = time;

			} else {

				direction.x = 0;
				direction.y = 0;
				velocity.y = 0;
				velocity.x = 0;
				moveForward = false;
			}

			renderer.render(currentScene, camera);
			//composer.render();
		}


		function TextureAnimator(texture, tilesHoriz, tilesVert, numTiles, tileDispDuration) {
			// note: texture passed by reference, will be updated by the update function.

			this.tilesHorizontal = tilesHoriz;
			this.tilesVertical = tilesVert;
			// how many images does this spritesheet contain?
			//  usually equals tilesHoriz * tilesVert, but not necessarily,
			//  if there at blank tiles at the bottom of the spritesheet. 
			this.numberOfTiles = numTiles;
			texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
			texture.repeat.set(1 / this.tilesHorizontal, 1 / this.tilesVertical);

			// how long should each image be displayed?
			this.tileDisplayDuration = tileDispDuration;

			// how long has the current image been displayed?
			this.currentDisplayTime = 0;

			// which image is currently being displayed?
			this.currentTile = 0;

			this.update = function (milliSec) {
				this.currentDisplayTime += milliSec;
				while (this.currentDisplayTime > this.tileDisplayDuration) {
					this.currentDisplayTime -= this.tileDisplayDuration;
					this.currentTile++;
					if (this.currentTile == this.numberOfTiles)
						this.currentTile = 0;
					var currentColumn = this.currentTile % this.tilesHorizontal;
					texture.offset.x = currentColumn / this.tilesHorizontal;
					var currentRow = Math.floor(this.currentTile / this.tilesHorizontal);
					texture.offset.y = currentRow / this.tilesVertical;
				}
			};
		}


		class ResourceTracker {
			constructor() {
				this.resources = new Set();
			}
			track(resource) {
				if (!resource) {
					return resource;
				}

				// handle children and when material is an array of materials or
				// uniform is array of textures
				if (Array.isArray(resource)) {
					resource.forEach(resource => this.track(resource));
					return resource;
				}

				if (resource.dispose || resource instanceof THREE.Object3D) {
					this.resources.add(resource);
				}
				if (resource instanceof THREE.Object3D) {
					this.track(resource.geometry);
					this.track(resource.material);
					this.track(resource.children);
				} else if (resource instanceof THREE.Material) {
					// We have to check if there are any textures on the material
					for (const value of Object.values(resource)) {
						if (value instanceof THREE.Texture) {
							this.track(value);
						}
					}
					// We also have to check if any uniforms reference textures or arrays of textures
					if (resource.uniforms) {
						for (const value of Object.values(resource.uniforms)) {
							if (value) {
								const uniformValue = value.value;
								if (uniformValue instanceof THREE.Texture ||
									Array.isArray(uniformValue)) {
									this.track(uniformValue);
								}
							}
						}
					}
				}
				return resource;
			}
			untrack(resource) {
				this.resources.delete(resource);
			}
			dispose() {
				for (const resource of this.resources) {
					if (resource instanceof THREE.Object3D) {
						if (resource.parent) {
							resource.parent.remove(resource);
						}
					}
					if (resource.dispose) {
						resource.dispose();
					}
				}
				this.resources.clear();
			}
		}



	</script>


	<div id="footer">

		<a>Space</a> <a>Fire</a> <a>UFO</a> <a>AtomGas</a>

	</div>

	<div id="forward">
		<div style="width: 33.33%; height: 50%; float: left;"></div>
		<div id='up' style="width: 33.33%; height: 50%; float: left; "></div>
		<div style="width: 33.33%; height: 50%; float: right;"></div>

		<div id='left' style="width: 33.33%; height: 50%; float: left;"></div>
		<div id='down' style="width: 33.33%; height: 50%; float: left; "></div>
		<div id='right' style="width: 33.33%; height: 50%; float: right;"></div>

	</div>

</body>

</html>